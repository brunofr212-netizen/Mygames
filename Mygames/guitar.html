<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Finger Shredder</title>
    <style>
        :root {
            /* Left Hand Colors */
            --lane-1: #ff0055; /* A - Red/Pink */
            --lane-2: #ff5500; /* S - Orange */
            --lane-3: #ffcc00; /* D - Gold */
            --lane-4: #ffff00; /* F - Yellow */
            /* Right Hand Colors */
            --lane-5: #00ff55; /* H - Green */
            --lane-6: #00ffff; /* J - Cyan */
            --lane-7: #0055ff; /* K - Blue */
            --lane-8: #aa00ff; /* L - Purple */
            
            --bg-color: #050510;
            --text-glow: 0 0 10px rgba(255,255,255,0.8);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Critical for mobile game */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
        }

        #score-board {
            position: absolute;
            top: 20px;
            font-size: 42px;
            font-weight: 800;
            text-shadow: var(--text-glow);
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        #combo-display {
            position: absolute;
            top: 70px;
            font-size: 28px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            transition: transform 0.1s;
        }

        #multiplier-display {
            position: absolute;
            top: 105px;
            font-size: 24px;
            color: #ffcc00;
            text-shadow: 0 0 5px #ffcc00;
        }
        
        #autoplay-indicator {
            position: absolute;
            top: 140px;
            font-size: 18px;
            color: #ff0055;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border: 1px solid #ff0055;
            border-radius: 4px;
            display: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        #section-display {
            position: absolute;
            bottom: 20%;
            font-size: 80px;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 10px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #game-canvas {
            background: linear-gradient(180deg, #020205 0%, #101020 100%);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-left: 2px solid #333;
            border-right: 2px solid #333;
            height: 100vh;
            width: 100%;
            max-width: 800px;
            touch-action: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
            backdrop-filter: blur(5px);
            overflow-y: auto; /* Allow scrolling on small screens if menu is tall */
        }

        h1 {
            font-size: 72px;
            margin: 20px 0 10px 0;
            background: linear-gradient(90deg, #ff0055, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 6px;
            text-align: center;
        }
        
        h2 {
            font-size: 24px;
            color: #fff;
            margin-bottom: 30px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        /* Toggle Switch Styles */
        .controls-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid #333;
        }

        .toggle-label {
            font-size: 16px;
            font-weight: bold;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        .track-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .track-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            padding: 20px;
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-left: 5px solid #333;
        }

        .track-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #00ffff;
            border-left-color: #00ffff;
            transform: translateX(10px);
        }

        .track-details {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .track-name {
            font-weight: 800;
            font-size: 20px;
            color: #fff;
            margin-bottom: 4px;
        }

        .track-meta {
            font-size: 12px;
            color: #888;
        }

        .track-difficulty {
            font-weight: bold;
            font-size: 14px;
            padding: 4px 10px;
            background: #222;
            border-radius: 4px;
        }
        
        /* Difficulty Colors */
        .diff-easy { color: #00ff55; }
        .diff-hard { color: #ff0055; }
        .diff-adaptive { color: #00ffff; }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border: 2px solid #00ffff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            font-weight: 800;
            letter-spacing: 2px;
        }

        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            line-height: 1.8;
            color: #ccc;
            background: rgba(255,255,255,0.05);
            padding: 20px 40px;
            border-radius: 10px;
            border: 1px solid #333;
            max-width: 80%;
            margin-bottom: 20px;
        }

        .hands-container {
            display: flex;
            gap: 40px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .hand-block {
            text-align: center;
        }
        
        .hand-title {
            color: #888;
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .key-badge {
            display: inline-block;
            width: 36px;
            height: 36px;
            line-height: 36px;
            border-bottom: 4px solid #555;
            border-radius: 6px;
            background: #222;
            color: #fff;
            margin: 0 4px;
            font-weight: bold;
            font-family: monospace;
            font-size: 18px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
        }

        /* Lane Colors for Badges */
        .k-a { border-color: var(--lane-1); color: var(--lane-1); }
        .k-s { border-color: var(--lane-2); color: var(--lane-2); }
        .k-d { border-color: var(--lane-3); color: var(--lane-3); }
        .k-f { border-color: var(--lane-4); color: var(--lane-4); }
        .k-h { border-color: var(--lane-5); color: var(--lane-5); }
        .k-j { border-color: var(--lane-6); color: var(--lane-6); }
        .k-k { border-color: var(--lane-7); color: var(--lane-7); }
        .k-l { border-color: var(--lane-8); color: var(--lane-8); }
        
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: 900;
            font-style: italic;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            -webkit-text-stroke: 1px rgba(0,0,0,0.5);
        }

        .restart-ui {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        /* Responsive Tweaks for Mobile */
        @media (max-width: 600px) {
            h1 { font-size: 42px; margin-top: 10px; }
            h2 { font-size: 18px; margin-bottom: 20px; }
            .track-btn { padding: 15px; }
            .track-name { font-size: 16px; }
            .key-badge { width: 24px; height: 24px; line-height: 24px; font-size: 14px; margin: 0 1px; }
            .hands-container { gap: 10px; }
            .controls-row { flex-direction: column; gap: 10px; }
            .instructions { padding: 15px; }
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div id="score-board">0</div>
        <div id="combo-display"></div>
        <div id="multiplier-display"></div>
        <div id="autoplay-indicator">Autoplay Mode</div>
        <div id="section-display"></div>
        <div id="feedback"></div>
    </div>

    <div id="start-screen">
        <h1>Neon Shredder</h1>
        <h2>Select Track</h2>
        
        <div id="main-menu-content">
            
            <div class="controls-row">
                <div class="toggle-container">
                    <span class="toggle-label">Autoplay</span>
                    <label class="switch">
                        <input type="checkbox" id="autoplay-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="toggle-container">
                    <span class="toggle-label">Touch Controls</span>
                    <label class="switch">
                        <input type="checkbox" id="touch-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div class="track-list" id="track-list-container">
                <!-- Tracks injected via JS -->
            </div>

            <div class="instructions" id="instruction-box">
                <p id="instruction-text">Use your keyboard to play the notes.</p>
                <div class="hands-container" id="key-legend">
                    <div class="hand-block">
                        <div class="hand-title">Left Hand</div>
                        <span class="key-badge k-a">A</span>
                        <span class="key-badge k-s">S</span>
                        <span class="key-badge k-d">D</span>
                        <span class="key-badge k-f">F</span>
                    </div>
                    <div class="hand-block">
                        <div class="hand-title">Right Hand</div>
                        <span class="key-badge k-h">H</span>
                        <span class="key-badge k-j">J</span>
                        <span class="key-badge k-k">K</span>
                        <span class="key-badge k-l">L</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-over-content" class="restart-ui">
            <h2 style="font-size: 40px; margin-bottom: 10px;">Set Complete</h2>
            <p style="font-size: 24px; color: white; margin-bottom: 30px;">Score: <span id="final-score">0</span></p>
            <button class="btn" id="return-menu-btn">Return to Menu</button>
        </div>
    </div>

    <script>
        /**
         * CONFIGURATION & CONSTANTS
         */
        const KEYS = ['a', 's', 'd', 'f', 'h', 'j', 'k', 'l'];
        const LANE_COLORS = [
            '#ff0055', '#ff5500', '#ffcc00', '#ffff00', 
            '#00ff55', '#00ffff', '#0055ff', '#aa00ff'
        ];
        
        const SCALE_FREQUENCIES = [
            110.00, // A2  (A)
            130.81, // C3  (S)
            146.83, // D3  (D)
            155.56, // Eb3 (F)
            164.81, // E3  (H)
            196.00, // G3  (J)
            220.00, // A3  (K)
            261.63  // C4  (L)
        ];

        let BPM = 120;
        let BEAT_DURATION = 60 / BPM;
        const HIT_WINDOW = 0.15;
        const NOTE_SPEED = 600;

        // Track Definitions
        const TRACK_LIBRARY = [
            {
                id: 'proc_infinite',
                name: 'Infinite Jam',
                meta: 'Procedural • Endless Rock',
                difficulty: 'Adaptive',
                diffClass: 'diff-adaptive',
                bpm: 120,
                type: 'generative'
            },
            {
                id: 'neon_sunrise',
                name: 'Neon Sunrise',
                meta: 'Fixed • Synthwave • 2min',
                difficulty: 'Easy',
                diffClass: 'diff-easy',
                bpm: 105,
                type: 'static',
                structure: [
                    { name: 'INTRO', type: 'intro', measures: 2 },
                    { name: 'VERSE', type: 'verse_basic', measures: 4 },
                    { name: 'CHORUS', type: 'chorus_simple', measures: 4 },
                    { name: 'VERSE', type: 'verse_basic', measures: 4 },
                    { name: 'CHORUS', type: 'chorus_simple', measures: 4 },
                    { name: 'OUTRO', type: 'outro', measures: 2 }
                ]
            },
            {
                id: 'cyber_storm',
                name: 'Cyber Storm',
                meta: 'Fixed • Hard Rock • 2min',
                difficulty: 'Hard',
                diffClass: 'diff-hard',
                bpm: 145,
                type: 'static',
                structure: [
                    { name: 'INTRO', type: 'intro', measures: 2 },
                    { name: 'RIFF', type: 'verse_heavy', measures: 4 },
                    { name: 'SOLO A', type: 'solo_fast', measures: 4 },
                    { name: 'RIFF', type: 'verse_heavy', measures: 4 },
                    { name: 'SOLO B', type: 'solo_fast', measures: 8 },
                    { name: 'OUTRO', type: 'outro', measures: 2 }
                ]
            }
        ];
        
        /**
         * AUDIO ENGINE
         */
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.reverb = null;
                this.isSetup = false;
            }

            init() {
                if (this.isSetup) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                
                this.reverb = this.ctx.createConvolver();
                this.generateReverbImpulse();

                this.masterGain.connect(this.reverb);
                this.reverb.connect(this.ctx.destination);
                this.masterGain.connect(this.ctx.destination);
                
                this.isSetup = true;
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            generateReverbImpulse() {
                let rate = this.ctx.sampleRate;
                let length = rate * 2.0; 
                let impulse = this.ctx.createBuffer(2, length, rate);
                let left = impulse.getChannelData(0);
                let right = impulse.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    let decay = Math.pow(1 - i / length, 2);
                    left[i] = (Math.random() * 2 - 1) * decay * 0.5;
                    right[i] = (Math.random() * 2 - 1) * decay * 0.5;
                }
                this.reverb.buffer = impulse;
            }

            playKick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time);
                osc.stop(time + 0.5);
            }

            playSnare(time) {
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) { output[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                const noiseEnvelope = this.ctx.createGain();
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseEnvelope);
                noiseEnvelope.connect(this.masterGain);
                noiseEnvelope.gain.setValueAtTime(0.7, time);
                noiseEnvelope.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
            }

            playHiHat(time, open = false) {
                const bufferSize = this.ctx.sampleRate * (open ? 0.3 : 0.05);
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + (open ? 0.2 : 0.05));
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start(time);
            }

            playNote(laneIndex, time = 0) {
                const now = time || this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = SCALE_FREQUENCIES[laneIndex];
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.Q.value = 4;
                filter.frequency.setValueAtTime(500, now);
                filter.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
                filter.frequency.exponentialRampToValueAtTime(800, now + 0.4);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.5, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.3, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
            }
            
            playMissSound() {
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.linearRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.15);
            }
        }

        /**
         * GAME LOGIC
         */
        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.audio = new AudioEngine();
                
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.songData = [];
                this.startTime = 0;
                this.isPlaying = false;
                this.isAutoplay = false;
                this.isTouchMode = false;
                this.songDuration = 0;
                this.currentTrack = null;
                
                this.score = 0;
                this.combo = 0;
                this.multiplier = 1;
                this.lanes = new Array(8).fill(null).map(() => ({ pressed: false, pressTime: 0 }));
                
                // Bindings
                this.handleKeyDown = this.handleKeyDown.bind(this);
                this.handleKeyUp = this.handleKeyUp.bind(this);
                this.handleTouchStart = this.handleTouchStart.bind(this);
                this.handleTouchEnd = this.handleTouchEnd.bind(this);
                this.loop = this.loop.bind(this);
                this.startGame = this.startGame.bind(this);
                this.returnToMenu = this.returnToMenu.bind(this);
                this.updateInstructions = this.updateInstructions.bind(this);

                // Listeners
                window.addEventListener('keydown', this.handleKeyDown);
                window.addEventListener('keyup', this.handleKeyUp);
                document.getElementById('return-menu-btn').addEventListener('click', this.returnToMenu);
                
                // Touch Listeners
                this.canvas.addEventListener('touchstart', this.handleTouchStart, {passive: false});
                this.canvas.addEventListener('touchend', this.handleTouchEnd, {passive: false});
                
                // Autoplay Toggle
                document.getElementById('autoplay-toggle').addEventListener('change', (e) => {
                    this.isAutoplay = e.target.checked;
                });

                // Touch Mode Toggle
                const touchToggle = document.getElementById('touch-toggle');
                touchToggle.addEventListener('change', (e) => {
                    this.isTouchMode = e.target.checked;
                    this.updateInstructions();
                });

                // Auto-detect Mobile/Touch
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    this.isTouchMode = true;
                    touchToggle.checked = true;
                }
                
                this.updateInstructions();
                this.renderMenu();
            }

            renderMenu() {
                const container = document.getElementById('track-list-container');
                container.innerHTML = '';
                
                TRACK_LIBRARY.forEach(track => {
                    const btn = document.createElement('div');
                    btn.className = 'track-btn';
                    btn.innerHTML = `
                        <div class="track-details">
                            <span class="track-name">${track.name}</span>
                            <span class="track-meta">${track.meta}</span>
                        </div>
                        <span class="track-difficulty ${track.diffClass}">${track.difficulty}</span>
                    `;
                    btn.onclick = () => this.startGame(track);
                    container.appendChild(btn);
                });
            }

            updateInstructions() {
                const text = document.getElementById('instruction-text');
                const legend = document.getElementById('key-legend');
                
                if (this.isTouchMode) {
                    text.innerHTML = "Tap the lanes on screen to play!";
                    legend.style.display = 'none'; // Hide key letters for touch
                } else {
                    text.innerHTML = "Use your keyboard to play the notes.";
                    legend.style.display = 'flex';
                }
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.laneWidth = this.canvas.width / 8;
                this.hitLineY = this.canvas.height - (this.canvas.height * 0.15); // Dynamic hitline position
            }

            handleKeyDown(e) {
                if (!this.isPlaying || this.isAutoplay || e.repeat) return;
                const keyIndex = KEYS.indexOf(e.key.toLowerCase());
                if (keyIndex !== -1) {
                    this.lanes[keyIndex].pressed = true;
                    this.lanes[keyIndex].pressTime = Date.now();
                    this.checkHit(keyIndex);
                }
            }

            handleKeyUp(e) {
                if (this.isAutoplay) return;
                const keyIndex = KEYS.indexOf(e.key.toLowerCase());
                if (keyIndex !== -1) {
                    this.lanes[keyIndex].pressed = false;
                }
            }

            // TOUCH HANDLERS
            handleTouchStart(e) {
                if (!this.isPlaying || this.isAutoplay || !this.isTouchMode) return;
                e.preventDefault(); // Stop zoom/scroll

                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    // Map touch X to lane
                    // Since canvas is full width/height or handled by CSS, clientX works well
                    // But lets be precise relative to canvas
                    const rect = this.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    
                    if (x >= 0 && x <= rect.width) {
                        const laneIndex = Math.floor(x / this.laneWidth);
                        if (laneIndex >= 0 && laneIndex < 8 && !this.lanes[laneIndex].pressed) {
                            this.lanes[laneIndex].pressed = true;
                            this.lanes[laneIndex].pressTime = Date.now();
                            this.checkHit(laneIndex);
                        }
                    }
                }
            }

            handleTouchEnd(e) {
                 if (!this.isPlaying || this.isAutoplay || !this.isTouchMode) return;
                 e.preventDefault();

                 // For simplicity, we clear lanes based on active touches.
                 // Ideally we track touch IDs, but for a simple rhythm game,
                 // recalculating pressed lanes based on CURRENT touches is robust.
                 
                 // Reset all first
                 for(let i=0; i<8; i++) this.lanes[i].pressed = false;

                 // Re-enable those still held
                 for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const rect = this.canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    if (x >= 0 && x <= rect.width) {
                        const laneIndex = Math.floor(x / this.laneWidth);
                        if (laneIndex >= 0 && laneIndex < 8) {
                            this.lanes[laneIndex].pressed = true;
                        }
                    }
                 }
            }

            buildTrack(track) {
                this.songData = [];
                BPM = track.bpm;
                BEAT_DURATION = 60 / BPM;
                const startOffset = 2.0;
                let currentBeat = 0;

                let sections = [];
                if (track.type === 'generative') {
                     sections = [
                        { name: 'INTRO', measures: 2, type: 'intro' },
                        { name: 'JAM A', measures: 8, type: 'verse' },
                        { name: 'JAM B', measures: 8, type: 'chorus' },
                        { name: 'JAM A', measures: 8, type: 'verse' },
                        { name: 'JAM C', measures: 8, type: 'solo' },
                        { name: 'OUTRO', measures: 2, type: 'outro' }
                    ];
                } else {
                    sections = track.structure;
                }

                sections.forEach(section => {
                    this.songData.push({
                        type: 'marker',
                        text: section.name,
                        time: startOffset + (currentBeat * BEAT_DURATION),
                        processed: false
                    });

                    for (let m = 0; m < section.measures; m++) {
                        this.generateMeasure(startOffset, currentBeat, section.type, m);
                        currentBeat += 4;
                    }
                });

                this.songData.sort((a, b) => a.time - b.time);
                const lastEvent = this.songData[this.songData.length - 1];
                this.songDuration = lastEvent ? lastEvent.time + 4 : 10;
            }

            generateMeasure(startOffset, baseBeat, type, measureIdx) {
                const t = (beats) => startOffset + (baseBeat + beats) * BEAT_DURATION;
                
                if (type !== 'intro' && type !== 'outro') {
                    this.addEvent('kick', t(0));
                    this.addEvent('kick', t(2));
                    this.addEvent('snare', t(1));
                    this.addEvent('snare', t(3));
                }
                for(let i=0; i<4; i+=0.5) {
                    this.addEvent('hihat', t(i));
                }
                
                if (type === 'verse_basic') {
                    this.addNote(0, t(0));
                    this.addNote(0, t(0.5));
                    this.addNote(1, t(1.5));
                    this.addNote(0, t(2));
                    this.addNote(2, t(3));
                }
                
                if (type === 'chorus_simple') {
                    this.addNote(4, t(0));
                    this.addNote(5, t(1));
                    this.addNote(6, t(2));
                    this.addNote(7, t(3));
                    this.addNote(6, t(3.5));
                }

                if (type === 'verse_heavy') {
                    this.addNote(0, t(0));
                    this.addNote(0, t(0.5));
                    this.addNote(3, t(1)); 
                    this.addNote(0, t(1.5));
                    this.addNote(5, t(2)); 
                    this.addNote(3, t(3));
                    this.addNote(2, t(3.5));
                }

                if (type === 'solo_fast') {
                    const scale = measureIdx % 2 === 0 ? [4,5,6,7] : [7,6,5,4];
                    scale.forEach((lane, i) => this.addNote(lane, t(i*0.5)));
                    this.addNote(lane => Math.floor(Math.random()*4)+4, t(2));
                    this.addNote(lane => Math.floor(Math.random()*4)+4, t(2.25));
                    this.addNote(lane => Math.floor(Math.random()*4)+4, t(2.5));
                    this.addNote(lane => Math.floor(Math.random()*4)+4, t(2.75));
                }

                if (type === 'verse') {
                     this.addNote(0, t(0));
                     this.addNote(0, t(1.5));
                     this.addNote(5, t(2));
                     this.addNote(0, t(2.5));
                     this.addNote(2, t(3));
                     if(Math.random() > 0.5) this.addNote(1, t(3.5));
                }

                if (type === 'chorus') {
                    const arpPattern = [2, 7, 5, 4, 5, 7, 4, 5];
                    arpPattern.forEach((lane, i) => {
                        this.addNote(lane, t(i * 0.5));
                    });
                }
                
                if (type === 'solo') {
                    for (let i = 0; i < 4; i += 0.25) {
                        if (Math.random() > 0.4) {
                            const lane = Math.floor(Math.random() * 8);
                            this.addNote(lane, t(i));
                        }
                    }
                }
                
                if (type === 'intro' || type === 'outro') {
                    if (measureIdx % 2 === 0) this.addNote(0, t(0));
                }
            }

            addEvent(type, time) {
                this.songData.push({ type, time, processed: false });
            }

            addNote(lane, time) {
                const finalLane = typeof lane === 'function' ? lane() : lane;
                this.songData.push({
                    type: 'note',
                    lane: finalLane,
                    time: time,
                    hit: false,
                    processed: false
                });
            }

            startGame(track) {
                this.currentTrack = track;
                this.audio.init();
                this.audio.resume();
                this.buildTrack(track);
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('main-menu-content').style.display = 'flex';
                document.getElementById('game-over-content').style.display = 'none';
                document.getElementById('autoplay-indicator').style.display = this.isAutoplay ? 'block' : 'none';
                
                this.isPlaying = true;
                this.startTime = this.audio.ctx.currentTime;
                
                this.score = 0;
                this.combo = 0;
                this.multiplier = 1;
                this.updateUI();
                
                requestAnimationFrame(this.loop);
            }

            returnToMenu() {
                this.isPlaying = false;
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('main-menu-content').style.display = 'flex';
                document.getElementById('game-over-content').style.display = 'none';
            }

            endGame() {
                this.isPlaying = false;
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('main-menu-content').style.display = 'none';
                document.getElementById('game-over-content').style.display = 'flex';
                document.getElementById('final-score').innerText = this.score.toLocaleString();
            }

            checkHit(laneIndex) {
                const now = this.audio.ctx.currentTime;
                const gameTime = now - this.startTime;

                const validNotes = this.songData.filter(n => 
                    n.type === 'note' && 
                    n.lane === laneIndex && 
                    !n.hit && 
                    Math.abs(n.time - gameTime) < HIT_WINDOW
                );

                if (validNotes.length > 0) {
                    validNotes.sort((a, b) => Math.abs(a.time - gameTime) - Math.abs(b.time - gameTime));
                    const hitNote = validNotes[0];
                    hitNote.hit = true;
                    
                    const diff = Math.abs(hitNote.time - gameTime);
                    this.registerHit(diff);
                    this.audio.playNote(laneIndex, now);
                } else {
                    this.registerMiss(true);
                }
            }

            registerHit(diff) {
                let points = 50;
                let text = "GOOD";
                let color = "#aaa";

                if (diff < 0.04) {
                    points = 200;
                    text = "PERFECT";
                    color = "#fff";
                } else if (diff < 0.08) {
                    points = 100;
                    text = "GREAT";
                    color = "#ff0";
                }

                this.combo++;
                this.multiplier = 1 + Math.floor(this.combo / 8); 
                if(this.multiplier > 8) this.multiplier = 8;

                this.score += points * this.multiplier;
                this.showFeedback(text, color);
                this.updateUI();
            }

            registerMiss(isGhostTap = false) {
                this.combo = 0;
                this.multiplier = 1;
                this.showFeedback("MISS", "#f00");
                if(!isGhostTap) this.audio.playMissSound();
                this.updateUI();
            }

            showFeedback(text, color) {
                const el = document.getElementById('feedback');
                el.innerText = text;
                el.style.color = color;
                el.style.textShadow = `0 0 20px ${color}`;
                el.style.opacity = 1;
                el.style.transform = "translate(-50%, -50%) scale(1.5)";
                
                if (this.feedbackTimeout) clearTimeout(this.feedbackTimeout);
                this.feedbackTimeout = setTimeout(() => {
                    el.style.transition = "all 0.2s ease-out";
                    el.style.opacity = 0;
                    el.style.transform = "translate(-50%, -50%) scale(1)";
                }, 300);
            }

            showSection(text) {
                const el = document.getElementById('section-display');
                el.innerText = text;
                el.style.opacity = 1;
                setTimeout(() => { el.style.opacity = 0; }, 2000);
            }

            updateUI() {
                document.getElementById('score-board').innerText = this.score.toLocaleString();
                
                const comboEl = document.getElementById('combo-display');
                if(this.combo > 4) {
                    comboEl.innerText = `${this.combo} COMBO`;
                    comboEl.style.transform = `scale(${1 + Math.min(0.2, this.combo/100)})`;
                } else {
                     comboEl.innerText = "";
                     comboEl.style.transform = "scale(1)";
                }

                const multiEl = document.getElementById('multiplier-display');
                if (this.multiplier > 1) {
                    multiEl.innerText = `x${this.multiplier}`;
                } else {
                    multiEl.innerText = "";
                }
            }

            loop() {
                if (!this.isPlaying) return;

                const now = this.audio.ctx.currentTime;
                const gameTime = now - this.startTime;

                if (gameTime > this.songDuration) {
                    this.endGame();
                    return;
                }
                
                // AUTOPLAY LOGIC
                if (this.isAutoplay) {
                     this.songData.forEach(note => {
                        if (note.type === 'note' && !note.hit && Math.abs(note.time - gameTime) < 0.02) { 
                             note.hit = true;
                             this.registerHit(0);
                             this.audio.playNote(note.lane, now);
                             this.lanes[note.lane].pressed = true;
                             setTimeout(() => { this.lanes[note.lane].pressed = false; }, 100);
                        }
                     });
                }

                this.ctx.fillStyle = '#050510';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // --- Background Grid ---
                this.ctx.strokeStyle = "rgba(0, 255, 255, 0.1)";
                this.ctx.lineWidth = 1;
                const gridOffset = (gameTime * 200) % 100;
                for(let i=0; i<this.canvas.height; i+=100) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i + gridOffset);
                    this.ctx.lineTo(this.canvas.width, i + gridOffset);
                    this.ctx.stroke();
                }

                // --- Draw Lanes ---
                for (let i = 0; i < 8; i++) {
                    const x = i * this.laneWidth;
                    
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();

                    if (this.lanes[i].pressed) {
                        const grad = this.ctx.createLinearGradient(0, this.hitLineY, 0, 0);
                        grad.addColorStop(0, LANE_COLORS[i]);
                        grad.addColorStop(1, "transparent");
                        this.ctx.fillStyle = grad;
                        this.ctx.globalAlpha = 0.3;
                        this.ctx.fillRect(x, 0, this.laneWidth, this.hitLineY);
                        this.ctx.globalAlpha = 1.0;
                    }
                    
                    const cx = x + this.laneWidth/2;
                    const cy = this.hitLineY;
                    
                    this.ctx.strokeStyle = LANE_COLORS[i];
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x + 10, cy - 10, this.laneWidth - 20, 20);
                    
                    if (this.lanes[i].pressed) {
                         this.ctx.fillStyle = LANE_COLORS[i];
                         this.ctx.fillRect(x + 10, cy - 10, this.laneWidth - 20, 20);
                    }

                    // Only draw keys if NOT in touch mode
                    if (!this.isTouchMode) {
                        this.ctx.fillStyle = "#666";
                        this.ctx.font = "bold 24px monospace";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText(KEYS[i].toUpperCase(), cx, cy + 40);
                    }
                }

                // --- Process Audio Events ---
                const scheduleAhead = 0.1;
                this.songData.forEach(event => {
                    if (!event.processed && event.time <= gameTime + scheduleAhead) {
                        if (event.type === 'kick') this.audio.playKick(this.startTime + event.time);
                        if (event.type === 'snare') this.audio.playSnare(this.startTime + event.time);
                        if (event.type === 'hihat') this.audio.playHiHat(this.startTime + event.time);
                        if (event.type === 'marker') this.showSection(event.text);
                        
                        if (event.type !== 'note') event.processed = true;
                    }
                    
                    if (event.type === 'note' && !event.hit && !event.processed) {
                        if (gameTime > event.time + HIT_WINDOW) {
                            event.processed = true;
                            if (!this.isAutoplay) {
                                this.registerMiss();
                            }
                        }
                    }
                });

                // --- Render Notes ---
                this.songData.forEach(note => {
                    if (note.type !== 'note' || note.hit) return;

                    const timeDiff = note.time - gameTime;
                    const y = this.hitLineY - (timeDiff * NOTE_SPEED);

                    if (y > -100 && y < this.canvas.height) {
                        const x = note.lane * this.laneWidth;
                        
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = LANE_COLORS[note.lane];
                        this.ctx.fillStyle = LANE_COLORS[note.lane];
                        this.roundRect(this.ctx, x + 12, y - 10, this.laneWidth - 24, 20, 4, true);
                        this.ctx.shadowBlur = 0;
                        this.ctx.fillStyle = "rgba(255,255,255,0.7)";
                        this.ctx.fillRect(x + 15, y - 8, this.laneWidth - 30, 8);
                    }
                });

                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = "#fff";
                this.ctx.strokeStyle = "rgba(255,255,255,0.8)";
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.hitLineY);
                this.ctx.lineTo(this.canvas.width, this.hitLineY);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;

                requestAnimationFrame(this.loop);
            }
            
            roundRect(ctx, x, y, width, height, radius, fill) {
                if (typeof radius === 'undefined') { radius = 5; }
                if (typeof radius === 'number') { radius = {tl: radius, tr: radius, br: radius, bl: radius}; }
                ctx.beginPath();
                ctx.moveTo(x + radius.tl, y);
                ctx.lineTo(x + width - radius.tr, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                ctx.lineTo(x + width, y + height - radius.br);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                ctx.lineTo(x + radius.bl, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                ctx.lineTo(x, y + radius.tl);
                ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                ctx.closePath();
                if (fill) { ctx.fill(); } else { ctx.stroke(); }
            }
        }

        const game = new Game();
    </script>
</body>
</html>
