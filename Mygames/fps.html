<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Procedural - Krunker Style</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            user-select: none;
        }

        /* BOTÃO VOLTAR */
        .back-to-arcade {
            position: fixed; top: 1rem; left: 1rem; z-index: 10000;
            padding: 0.5rem 1rem; background: rgba(0,0,0,0.8);
            border: 1px solid #00f3ff; color: #00f3ff;
            font-family: 'Segoe UI', sans-serif; font-size: 0.75rem;
            text-decoration: none; text-transform: uppercase; font-weight: bold;
            border-radius: 4px; box-shadow: 0 0 10px rgba(0,243,255,0.3);
            transition: all 0.3s; pointer-events: auto;
        }
        .back-to-arcade:hover {
            background: #00f3ff; color: #000;
            box-shadow: 0 0 20px #00f3ff;
        }

        .lil-gui { z-index: 1001; }
        
        #instructions, #settings-menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; background-color: rgba(0, 0, 0, 0.7);
            color: white; cursor: default; z-index: 10;
            backdrop-filter: blur(5px);
        }
        #settings-menu { display: none; }
        #game-over {
            display: none; position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column; justify-content: center;
            align-items: center; background-color: rgba(100, 0, 0, 0.85);
            color: white; z-index: 20;
        }
        #damage-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0);
            pointer-events: none; transition: box-shadow 0.1s; z-index: 8;
        }
        #sniper-scope {
            display: none; position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 15;
            background: radial-gradient(circle, transparent 25%, black 25.5%);
        }
        #sniper-scope::before { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: rgba(0,0,0,0.8); transform: translateY(-50%); }
        #sniper-scope::after { content: ''; position: absolute; top: 0; left: 50%; width: 1px; height: 100%; background: rgba(0,0,0,0.8); transform: translateX(-50%); }

        h1 { font-size: 64px; text-shadow: 4px 4px 0px #000; margin-bottom: 20px; text-transform: uppercase; font-style: italic; letter-spacing: 2px; }
        h2 { font-size: 36px; margin-bottom: 20px; }
        p { font-size: 18px; color: #ddd; margin: 5px 0; }

        .menu-btn {
            padding: 20px 40px; font-size: 24px; cursor: pointer;
            background: #fff; border: 4px solid #ccc; border-radius: 8px;
            margin: 10px; font-weight: bold; text-transform: uppercase;
            transition: transform 0.1s, background 0.1s; min-width: 300px;
        }
        .menu-btn:hover { background: #e0e0e0; transform: scale(1.05); }
        .menu-btn:active { transform: scale(0.95); }
        #btn-training { background: #aaffaa; border-color: #44aa44; }
        #btn-training:hover { background: #99ee99; }
        .setting-row { margin: 20px; display: flex; flex-direction: column; align-items: center; }
        .setting-label { font-size: 24px; margin-bottom: 10px; font-weight: bold; }
        .setting-input { padding: 10px; font-size: 24px; text-align: center; width: 100px; border-radius: 5px; border: none; }

        #hud-container { position: absolute; bottom: 20px; left: 20px; display: flex; flex-direction: column; align-items: flex-start; pointer-events: none; z-index: 5; }
        #health-text { color: white; font-size: 32px; font-weight: bold; margin-right: 10px; text-shadow: 2px 2px 0 #000; }
        #health-bar-bg { width: 300px; height: 30px; background-color: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.2); border-radius: 4px; margin-bottom: 10px; }
        #health-bar-fill { width: 100%; height: 100%; background-color: #00ff00; transition: width 0.2s, background-color 0.2s; }
        #weapon-name { color: #00ffff; font-size: 24px; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px; }
        #score-container { position: absolute; top: 20px; right: 20px; text-align: right; pointer-events: none; z-index: 5; }
        #score-val { color: white; font-size: 42px; font-weight: bold; text-shadow: 2px 2px 0 #000; line-height: 1; }
        #kills-val { color: #ffcc00; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 0 #000; margin-top: 5px; }
        #kill-feed { position: absolute; top: 100px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; z-index: 5; }
        .feed-item { background-color: rgba(0, 0, 0, 0.6); color: white; padding: 8px 15px; margin-bottom: 5px; border-radius: 4px; font-size: 16px; border-left: 4px solid #ff0000; animation: fadeOut 4s forwards; font-weight: bold; }
        @keyframes fadeOut { 0% { opacity: 0; transform: translateX(20px); } 10% { opacity: 1; transform: translateX(0); } 80% { opacity: 1; } 100% { opacity: 0; pointer-events: none; } }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; z-index: 5; }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: #0f0; }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: #0f0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <a href="index.html" class="back-to-arcade">← Sair do Jogo</a>

    <div id="damage-overlay"></div>
    <div id="crosshair"></div>
    <div id="sniper-scope"></div>
    
    <div id="hud-container">
        <div id="health-text">100</div>
        <div id="health-bar-bg"><div id="health-bar-fill"></div></div>
        <div id="weapon-name">RIFLE</div>
    </div>

    <div id="score-container">
        <div id="score-val">0</div>
        <div id="kills-val">KILLS: 0</div>
    </div>

    <div id="kill-feed"></div>

    <div id="instructions">
        <h1>KRUNKER JS</h1>
        <div style="margin-bottom: 30px;">
            <button id="btn-procedural" class="menu-btn">MAPA PROCEDURAL</button>
            <br>
            <button id="btn-static" class="menu-btn">MAPA CLÁSSICO</button>
            <br>
            <button id="btn-training" class="menu-btn">MAPA TREINO</button>
            <br>
            <button id="btn-settings" class="menu-btn" style="background: #ddd; font-size: 20px; margin-top: 20px;">CONFIGURAÇÕES</button>
        </div>
        <div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;">
            <p>W, A, S, D = Mover | SHIFT = Correr</p>
            <p>ESPAÇO = Pular | CLICK ESQ = Disparar</p>
            <p>CLICK DIR = Mira (Sniper)</p>
            <p>1, 2, 3 = Trocar Armas</p>
        </div>
    </div>

    <div id="settings-menu">
        <h2>CONFIGURAÇÕES</h2>
        <div class="setting-row">
            <label class="setting-label" for="sens-input">Sensibilidade do Mouse</label>
            <input type="number" id="sens-input" class="setting-input" value="5.0" min="0.1" max="10.0" step="0.1">
            <p style="font-size: 14px; color: #aaa; margin-top: 5px;">(Padrão: 5.0 | Max: 10.0)</p>
        </div>
        <button id="btn-save-settings" class="menu-btn">SALVAR E VOLTAR</button>
    </div>

    <div id="game-over">
        <h1 style="color: #ff4444;">VOCÊ MORREU</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">
            <p>Pontuação: <span id="final-score" style="color: #ffff00;">0</span></p>
            <p>Kills: <span id="final-kills" style="color: #ffff00;">0</span></p>
        </div>
        <button class="menu-btn" onclick="location.reload()">MENU PRINCIPAL</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import GUI from 'lil-gui';

        class FPSControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.sensitivity = 5.0; 
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.vec = new THREE.Vector3(); 
                this.connect();
            }
            connect() {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
                document.addEventListener('pointerlockchange', this.onPointerLockChange.bind(this));
            }
            onMouseMove(event) {
                if (!this.isLocked) return;
                const factor = (this.sensitivity / 5.0) * 0.002;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.euler.setFromQuaternion(this.camera.quaternion);
                this.euler.y -= movementX * factor;
                this.euler.x -= movementY * factor;
                this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
                this.camera.quaternion.setFromEuler(this.euler);
            }
            onPointerLockChange() {
                this.isLocked = (document.pointerLockElement === this.domElement);
            }
            lock() { 
                const promise = this.domElement.requestPointerLock();
                if (promise && promise.catch) promise.catch(e => {});
            }
            unlock() { document.exitPointerLock(); }
            getObject() { return this.camera; }
            moveForward(d) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.vec.crossVectors(this.camera.up, this.vec);
                this.camera.position.addScaledVector(this.vec, d);
            }
            moveRight(d) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.camera.position.addScaledVector(this.vec, d);
            }
        }

        const MAP_SIZE = 200;
        const TILE_SIZE = 5;
        let camera, scene, renderer, controls;
        let mapGroup;
        let gameStarted = false;
        let isGameOver = false;
        let currentMapType = 'procedural'; 
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isSprinting = false;
        let isScoped = false; 
        let baseFov = 75;
        let baseSensitivity = 5.0; 
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let playerHealth = 100, lastDamageTime = 0, score = 0, kills = 0;
        const physicsParams = { speed: 100.0, jumpForce: 50.0, gravity: 2.0, playerHeight: 1.6 };
        let weapon, muzzle, weaponRecoil = 0, lastShotTime = 0;
        const raycaster = new THREE.Raycaster();
        const collidableObjects = []; 
        const shootableObjects = []; 
        const particles = []; 
        const bots = [];
        let currentWeapon = 'rifle';
        let audioCtx;

        const weapons = {
            rifle: { name: "RIFLE", damage: 34, fireRate: 150, range: 100, spread: 0.02, pellets: 1, recoil: 0.15, sound: 'shoot_rifle' },
            sniper: { name: "SNIPER", damage: 100, fireRate: 1000, range: 200, spread: 0.001, pellets: 1, recoil: 0.5, sound: 'shoot_sniper' },
            shotgun: { name: "SHOTGUN", damage: 20, fireRate: 800, range: 40, spread: 0.15, pellets: 6, recoil: 0.4, sound: 'shoot_shotgun' }
        };

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSpatialSound(type, position) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const panner = audioCtx.createStereoPanner();
            const now = audioCtx.currentTime;
            
            if (type === 'shoot_rifle') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.15);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.15);
                osc.start(now); osc.stop(now+0.2);
            } else if (type === 'shoot_sniper') {
                osc.type = 'square'; osc.frequency.setValueAtTime(1500, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.4);
                gainNode.gain.setValueAtTime(0.5, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.4);
                osc.start(now); osc.stop(now+0.4);
            } else if (type === 'shoot_shotgun') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.3);
                gainNode.gain.setValueAtTime(0.5, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.3);
                const lfo = audioCtx.createOscillator(); lfo.frequency.value = 50; lfo.connect(gainNode.gain); lfo.start(now); lfo.stop(now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'shoot_enemy') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.2);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.2);
                osc.start(now); osc.stop(now+0.25);
            } else if (type === 'jump') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(300, now+0.1);
                gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.linearRampToValueAtTime(0.01, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'hit_marker' || type === 'pain') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(type==='pain'?150:2000, now);
                gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.05);
                osc.start(now); osc.stop(now+0.05);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.5);
                gainNode.gain.setValueAtTime(0.4, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.5);
                osc.start(now); osc.stop(now+0.5);
            }

            if (position) {
                const dist = camera.position.distanceTo(position);
                const maxDist = 60;
                let vol = Math.max(0, 1 - (dist / maxDist));
                const distGain = audioCtx.createGain(); distGain.gain.value = vol * vol;
                const localPos = position.clone().sub(camera.position).applyQuaternion(camera.quaternion.clone().invert());
                panner.pan.value = Math.max(-1, Math.min(1, localPos.x / 20));
                osc.connect(gainNode); gainNode.connect(distGain); distGain.connect(panner); panner.connect(audioCtx.destination);
            } else {
                osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            }
        }

        function setupGUI() {
            const gui = new GUI({ title: 'Configurações' });
            const fp = gui.addFolder('Física');
            fp.add(physicsParams, 'speed', 10, 500); fp.add(physicsParams, 'jumpForce', 10, 200); fp.add(physicsParams, 'gravity', 0, 20);
        }

        function setScope(state) {
            isScoped = state;
            document.getElementById('sniper-scope').style.display = state ? 'block' : 'none';
            document.getElementById('crosshair').style.display = state ? 'none' : (controls.isLocked ? 'block' : 'none');
            camera.fov = state ? baseFov / 3 : baseFov;
            camera.updateProjectionMatrix();
            controls.sensitivity = state ? baseSensitivity * 0.3 : baseSensitivity;
            if (weapon) weapon.visible = !state;
        }

        function setupKeyboardControls() {
            const onKeyDown = (e) => {
                if (e.code==='KeyW') moveForward=true; else if (e.code==='KeyA') moveLeft=true;
                else if (e.code==='KeyS') moveBackward=true; else if (e.code==='KeyD') moveRight=true;
                else if (e.code==='ShiftLeft') isSprinting=true;
                else if (e.code==='Space' && canJump) { velocity.y += physicsParams.jumpForce; canJump=false; playSpatialSound('jump'); }
                else if (e.code === 'Digit1') switchWeapon('rifle');
                else if (e.code === 'Digit2') switchWeapon('sniper');
                else if (e.code === 'Digit3') switchWeapon('shotgun');
            };
            const onKeyUp = (e) => {
                if (e.code==='KeyW') moveForward=false; else if (e.code==='KeyA') moveLeft=false;
                else if (e.code==='KeyS') moveBackward=false; else if (e.code==='KeyD') moveRight=false;
                else if (e.code==='ShiftLeft') isSprinting=false;
            };
            document.addEventListener('mousedown', (e) => {
                if (gameStarted && !isGameOver && controls.isLocked) {
                    if (e.button === 0) shoot();
                    if (e.button === 2 && currentWeapon === 'sniper') setScope(true);
                }
            });
            document.addEventListener('mouseup', (e) => { if (e.button === 2) setScope(false); });
            document.addEventListener('contextmenu', event => event.preventDefault());
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        }

        class Bot {
            constructor(x, z) {
                this.group = new THREE.Group();
                this.health = 100; this.isDead = false;
                const matSkin = new THREE.MeshLambertMaterial({ color: 0xffdbac });
                const matUniform = new THREE.MeshLambertMaterial({ color: 0x2a3b4c });
                this.torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.45), matUniform);
                this.torso.position.y = 1.4; this.torso.castShadow = true; this.torso.userData = { parentBot: this };
                this.group.add(this.torso);
                this.head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.45, 0.45), matSkin);
                this.head.position.y = 0.7; this.head.castShadow = true; this.head.userData = { parentBot: this };
                this.torso.add(this.head);
                this.armL = new THREE.Group(); this.armL.position.set(-0.5, 0.3, 0); this.torso.add(this.armL);
                const meshArmL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matUniform); meshArmL.position.y = -0.3; this.armL.add(meshArmL);
                this.armR = new THREE.Group(); this.armR.position.set(0.5, 0.3, 0); this.torso.add(this.armR);
                const meshArmR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matUniform); meshArmR.position.y = -0.3; this.armR.add(meshArmR);
                this.legL = new THREE.Group(); this.legL.position.set(-0.2, -0.4, 0); this.torso.add(this.legL);
                const meshLegL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matUniform); meshLegL.position.y = -0.4; this.legL.add(meshLegL);
                this.legR = new THREE.Group(); this.legR.position.set(0.2, -0.4, 0); this.torso.add(this.legR);
                const meshLegR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matUniform); meshLegR.position.y = -0.4; this.legR.add(meshLegR);
                this.group.position.set(x, 0, z); scene.add(this.group);
                shootableObjects.push(this.torso, this.head, meshArmL, meshArmR, meshLegL, meshLegR);
                this.direction = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                this.changeDirTimer = 0; this.speed = 4.0; this.velocity = new THREE.Vector3();
                this.isGrounded = false; this.jumpTimer = Math.random()*5+2; this.shootTimer = 0; this.detectionRange = 40; this.animTime = Math.random() * 100;
                this.isTrainingTarget = (currentMapType === 'training');
            }
            update(delta, playerPos) {
                if (this.isDead) return;
                const dist = this.group.position.distanceTo(playerPos);
                if (dist < this.detectionRange && !isGameOver) {
                    this.group.lookAt(playerPos.x, this.group.position.y, playerPos.z);
                    this.shootTimer -= delta;
                    if (this.shootTimer <= 0) { this.shootAtPlayer(playerPos); this.shootTimer = Math.random()*0.5 + 0.5; }
                }
                this.velocity.y -= 200.0 * delta; this.group.position.y += this.velocity.y * delta;
                if (this.group.position.y <= 0) { this.group.position.y = 0; this.velocity.y = 0; }
                const move = this.direction.clone().multiplyScalar(this.speed * delta);
                this.group.position.add(move);
                if (Math.abs(this.group.position.x) > MAP_SIZE/2-2 || Math.abs(this.group.position.z) > MAP_SIZE/2-2) this.direction.multiplyScalar(-1);
            }
            shootAtPlayer(playerPos) {
                const start = this.group.position.clone(); start.y += 1.8;
                playSpatialSound('shoot_enemy', start);
                const dir = new THREE.Vector3().subVectors(playerPos, start).normalize();
                const dist = start.distanceTo(playerPos);
                const ray = new THREE.Raycaster(start, dir, 0, dist);
                const hits = ray.intersectObjects(shootableObjects.filter(o => !o.userData.parentBot), true);
                if (hits.length === 0) playerTakeDamage(10);
            }
            takeDamage(amount) {
                if (this.isDead) return;
                this.health -= amount; playSpatialSound('hit_marker');
                if (this.health <= 0) this.die();
            }
            die() {
                this.isDead = true; addScore(100); addToKillFeed("Inimigo Eliminado +100");
                playSpatialSound('explosion', this.group.position);
                scene.remove(this.group); bots.splice(bots.indexOf(this), 1);
                spawnBot();
            }
        }

        function createWeapon() {
            weapon = new THREE.Group();
            const dark = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), dark); body.position.z = 0.1; weapon.add(body);
            muzzle = new THREE.Object3D(); muzzle.position.set(0, 0.02, -0.52); weapon.add(muzzle);
            weapon.position.set(0.3, -0.3, -0.6);
            camera.add(weapon);
            document.getElementById('weapon-name').innerText = weapons[currentWeapon].name;
        }

        function switchWeapon(type) {
            currentWeapon = type; camera.remove(weapon); createWeapon();
        }

        function createBulletTracer(start, end, color) {
            const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: color }));
            scene.add(line); setTimeout(() => { scene.remove(line); }, 100);
        }

        function addScore(pts) { score+=pts; kills++; document.getElementById('score-val').innerText=score; document.getElementById('kills-val').innerText="KILLS: "+kills; }
        function addToKillFeed(txt) {
            const el = document.createElement('div'); el.className='feed-item'; el.innerText=txt;
            document.getElementById('kill-feed').prepend(el); setTimeout(() => el.remove(), 4000);
        }

        function playerTakeDamage(amt) {
            if (isGameOver) return;
            playerHealth -= amt; lastDamageTime = performance.now();
            updateHUD(); playSpatialSound('pain');
            if (playerHealth <= 0) {
                isGameOver = true; controls.unlock();
                document.getElementById('game-over').style.display = 'flex';
            }
        }

        function updateHUD() {
            document.getElementById('health-text').innerText = Math.ceil(playerHealth);
            document.getElementById('health-bar-fill').style.width = playerHealth + "%";
        }

        function spawnBot() {
            bots.push(new Bot((Math.random()-0.5)*180, (Math.random()-0.5)*180));
        }

        function startGame(mode) {
            initAudio();
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            controls.lock();
            gameStarted = true;
            for(let i=0; i<8; i++) spawnBot();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); const delta = (time - prevTime) / 1000;
            bots.forEach(b => b.update(delta, camera.position));
            if (controls.isLocked && !isGameOver) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= physicsParams.gravity * 100.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * physicsParams.speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * physicsParams.speed * delta;
                controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);
                if (controls.getObject().position.y < physicsParams.playerHeight) { velocity.y = 0; controls.getObject().position.y = physicsParams.playerHeight; canJump = true; }
            }
            prevTime = time; renderer.render(scene, camera);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new FPSControls(camera, document.body);
            createWeapon();
            const amb = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(amb);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI / 2; scene.add(floor); shootableObjects.push(floor);
            setupKeyboardControls();
            document.getElementById('btn-procedural').addEventListener('click', () => startGame('procedural'));
            document.getElementById('btn-static').addEventListener('click', () => startGame('static'));
            document.getElementById('btn-training').addEventListener('click', () => startGame('training'));
        }

        init(); animate();
    </script>
</body>
</html>
