<!DOCTYPE html>
<html lang="pt-pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FPS Procedural - Krunker Style</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            user-select: none;
            touch-action: none; 
        }

        .lil-gui { z-index: 1001; }
        
        /* UI de Instruções / Menu */
        #instructions, #settings-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            cursor: default;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        #settings-menu { display: none; }

        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(100, 0, 0, 0.85);
            color: white;
            z-index: 20;
        }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: box-shadow 0.1s;
            z-index: 8;
        }

        /* LUNETA SNIPER */
        #sniper-scope {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 15;
            background: radial-gradient(circle, transparent 25%, black 25.5%);
        }
        #sniper-scope::before {
            content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: rgba(0,0,0,0.8); transform: translateY(-50%);
        }
        #sniper-scope::after {
            content: ''; position: absolute; top: 0; left: 50%; width: 1px; height: 100%; background: rgba(0,0,0,0.8); transform: translateX(-50%);
        }

        /* MOBILE CONTROLS */
        #mobile-controls {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 18;
        }

        .touch-zone {
            position: absolute;
            pointer-events: auto;
        }

        #joystick-zone-l {
            bottom: 30px; left: 30px; width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #joystick-knob-l {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #aim-zone {
            top: 0; right: 0; width: 50%; height: 100%;
        }

        .mobile-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto;
            user-select: none;
            font-size: 16px;
        }
        .mobile-btn:active { background: rgba(255, 255, 255, 0.5); }

        #btn-shoot {
            bottom: 60px; right: 30px; width: 70px; height: 70px;
            background: rgba(255, 50, 50, 0.25);
            border-color: rgba(255, 50, 50, 0.5);
        }
        #btn-jump {
            bottom: 150px; right: 40px; width: 55px; height: 55px;
        }
        #btn-switch {
            bottom: 40px; right: 120px; width: 55px; height: 55px;
            border-radius: 12px;
        }
        #btn-scope {
            bottom: 120px; right: 110px; width: 45px; height: 45px;
            font-size: 12px;
        }

        /* Aviso de Orientação */
        #rotate-device {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: white;
            z-index: 9999;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center;
        }
        
        @media screen and (orientation: portrait) {
            #rotate-device { display: flex !important; }
        }

        h1 {
            font-size: 64px;
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 20px;
            text-transform: uppercase;
            font-style: italic;
            letter-spacing: 2px;
        }

        h2 { font-size: 36px; margin-bottom: 20px; }

        p { font-size: 18px; color: #ddd; margin: 5px 0; }

        .menu-btn {
            padding: 20px 40px;
            font-size: 24px;
            cursor: pointer;
            background: #fff;
            border: 4px solid #ccc;
            border-radius: 8px;
            margin: 10px;
            font-weight: bold;
            text-transform: uppercase;
            transition: transform 0.1s, background 0.1s;
            min-width: 300px;
        }
        .menu-btn:hover { background: #e0e0e0; transform: scale(1.05); }
        .menu-btn:active { transform: scale(0.95); }

        /* Botão Resume */
        #btn-resume {
            background: #ffaa44;
            border-color: #cc8822;
            display: none; /* Só aparece quando o jogo está rodando */
        }
        #btn-resume:hover { background: #ffbb66; }

        @media (max-height: 500px) {
            h1 { font-size: 32px; margin-bottom: 10px; }
            .menu-btn {
                padding: 10px 20px;
                font-size: 16px;
                min-width: 200px;
                margin: 5px;
            }
            p { font-size: 12px; }
            #instructions div { margin-bottom: 10px; }
            #hud-container { bottom: 10px; left: 10px; transform: scale(0.8); transform-origin: bottom left; }
            #score-container { top: 10px; right: 10px; transform: scale(0.8); transform-origin: top right; }
            #kill-feed { top: 60px; right: 10px; transform: scale(0.8); transform-origin: top right; }
        }

        #btn-training {
            background: #aaffaa;
            border-color: #44aa44;
        }
        #btn-training:hover { background: #99ee99; }

        .setting-row { margin: 20px; display: flex; flex-direction: column; align-items: center; }
        .setting-label { font-size: 24px; margin-bottom: 10px; font-weight: bold; }
        .setting-input { padding: 10px; font-size: 24px; text-align: center; width: 100px; border-radius: 5px; border: none; }

        /* HUD */
        #hud-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; flex-direction: column; align-items: flex-start;
            pointer-events: none; z-index: 5;
        }
        #health-text { color: white; font-size: 32px; font-weight: bold; margin-right: 10px; text-shadow: 2px 2px 0 #000; }
        #health-bar-bg {
            width: 300px; height: 30px; background-color: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2); border-radius: 4px; margin-bottom: 10px;
        }
        #health-bar-fill { width: 100%; height: 100%; background-color: #00ff00; transition: width 0.2s, background-color 0.2s; }
        #weapon-name {
            color: #00ffff; font-size: 24px; font-weight: bold; text-transform: uppercase;
            letter-spacing: 2px; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.5);
            padding: 5px 15px; border-radius: 4px;
        }

        #score-container {
            position: absolute; top: 20px; right: 20px; text-align: right; pointer-events: none; z-index: 5;
        }
        #score-val { color: white; font-size: 42px; font-weight: bold; text-shadow: 2px 2px 0 #000; line-height: 1; }
        #kills-val { color: #ffcc00; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 0 #000; margin-top: 5px; }

        #kill-feed {
            position: absolute; top: 100px; right: 20px;
            display: flex; flex-direction: column; align-items: flex-end;
            pointer-events: none; z-index: 5;
        }
        .feed-item {
            background-color: rgba(0, 0, 0, 0.6); color: white; padding: 8px 15px;
            margin-bottom: 5px; border-radius: 4px; font-size: 16px;
            border-left: 4px solid #ff0000; animation: fadeOut 4s forwards; font-weight: bold;
        }
        @keyframes fadeOut {
            0% { opacity: 0; transform: translateX(20px); }
            10% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; pointer-events: none; }
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 5;
        }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: #0f0; }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: #0f0; }
        
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="rotate-device">
        <h1>GIRE O DISPOSITIVO</h1>
        <p>Este jogo requer modo paisagem (Landscape).</p>
    </div>

    <div id="damage-overlay"></div>
    <div id="crosshair"></div>
    <div id="sniper-scope"></div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="joystick-zone-l" class="touch-zone">
            <div id="joystick-knob-l"></div>
        </div>
        <div id="aim-zone" class="touch-zone"></div>
        
        <div id="btn-shoot" class="mobile-btn touch-zone">TIRO</div>
        <div id="btn-jump" class="mobile-btn touch-zone">PULO</div>
        <div id="btn-switch" class="mobile-btn touch-zone">ARMA</div>
        <div id="btn-scope" class="mobile-btn touch-zone">ZOOM</div>
    </div>

    <div id="hud-container">
        <div id="health-text">100</div>
        <div id="health-bar-bg"><div id="health-bar-fill"></div></div>
        <div id="weapon-name">RIFLE</div>
    </div>

    <div id="score-container">
        <div id="score-val">0</div>
        <div id="kills-val">KILLS: 0</div>
    </div>

    <div id="kill-feed"></div>

    <!-- Menu Principal -->
    <div id="instructions">
        <h1>KRUNKER JS</h1>
        <div style="margin-bottom: 20px;">
            <button id="btn-resume" class="menu-btn">CONTINUAR JOGO</button>
            <br>
            <button id="btn-procedural" class="menu-btn">MAPA PROCEDURAL</button>
            <br>
            <button id="btn-static" class="menu-btn">MAPA CLÁSSICO</button>
            <br>
            <button id="btn-training" class="menu-btn">MAPA TREINO</button>
            <br>
            <button id="btn-settings" class="menu-btn" style="background: #ddd; font-size: 20px; margin-top: 10px;">CONFIGURAÇÕES</button>
            <br>
            <button id="btn-mobile-toggle" class="menu-btn" style="background: #aaa; font-size: 16px;">ATIVAR MODO MOBILE</button>
            <br>
            <!-- Botão de Modo Desenvolvedor -->
            <button id="btn-dev-mode" class="menu-btn" style="background: #555; color: #ccc; font-size: 16px; margin-top: 5px;">MODO DEV: OFF</button>
        </div>
        <div style="background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;">
            <p>PC: WASD Mover | Espaço Pular | Mouse Atirar | ESC Menu</p>
            <p>MOBILE: Joystick Esq Mover | Dir Mirar | Botões</p>
        </div>
    </div>

    <div id="settings-menu">
        <h2>CONFIGURAÇÕES</h2>
        <div class="setting-row">
            <label class="setting-label" for="sens-input">Sensibilidade</label>
            <input type="number" id="sens-input" class="setting-input" value="5.0" min="0.1" max="10.0" step="0.1">
        </div>
        <button id="btn-save-settings" class="menu-btn">SALVAR E VOLTAR</button>
    </div>

    <div id="game-over">
        <h1 style="color: #ff4444;">VOCÊ MORREU</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">
            <p>Pontuação: <span id="final-score" style="color: #ffff00;">0</span></p>
            <p>Kills: <span id="final-kills" style="color: #ffff00;">0</span></p>
        </div>
        <button class="menu-btn" onclick="location.reload()">MENU PRINCIPAL</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import GUI from 'lil-gui';

        // --- CONTROLE DE MOUSE PERSONALIZADO ---
        class FPSControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.sensitivity = 5.0; 
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.vec = new THREE.Vector3(); 
                this.connect();
            }
            connect() {
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
                document.addEventListener('pointerlockchange', this.onPointerLockChange.bind(this));
                document.addEventListener('mozpointerlockchange', this.onPointerLockChange.bind(this));
                document.addEventListener('webkitpointerlockchange', this.onPointerLockChange.bind(this));
            }
            onMouseMove(event) {
                if (!this.isLocked || isMobileMode) return;
                const factor = (this.sensitivity / 5.0) * 0.002;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                this.rotateCamera(movementX * factor, movementY * factor);
            }
            rotateCamera(x, y) {
                this.euler.setFromQuaternion(this.camera.quaternion);
                this.euler.y -= x;
                this.euler.x -= y;
                this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
                this.camera.quaternion.setFromEuler(this.euler);
            }
            onPointerLockChange() {
                this.isLocked = (document.pointerLockElement === this.domElement || 
                                 document.mozPointerLockElement === this.domElement || 
                                 document.webkitPointerLockElement === this.domElement);
            }
            lock() { 
                if (isMobileMode) {
                    this.isLocked = true; // Simula travamento no mobile
                    return;
                }
                const promise = this.domElement.requestPointerLock();
                if (promise && promise.catch) promise.catch(e => {});
            }
            unlock() { 
                if (isMobileMode) {
                    this.isLocked = false;
                    return;
                }
                document.exitPointerLock(); 
            }
            getObject() { return this.camera; }
            moveForward(d) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.vec.crossVectors(this.camera.up, this.vec);
                this.camera.position.addScaledVector(this.vec, d);
            }
            moveRight(d) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.camera.position.addScaledVector(this.vec, d);
            }
        }

        // --- VARIÁVEIS GLOBAIS ---
        const MAP_SIZE = 200;
        const TILE_SIZE = 5;
        let camera, scene, renderer, controls;
        let mapGroup;
        let gameStarted = false;
        let isGameOver = false;
        let currentMapType = 'procedural'; 
        // Inputs
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let joystickVector = { x: 0, y: 0 }; 
        let canJump = false, isSprinting = false;
        let isScoped = false; 
        let baseFov = 75;
        let baseSensitivity = 5.0; 
        let isMobileMode = false; // Controle de modo mobile
        let isDevMode = false; // Controle modo dev
        let gui; // Referência para lil-gui

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let playerHealth = 100, lastDamageTime = 0, score = 0, kills = 0;
        const physicsParams = { speed: 100.0, jumpForce: 50.0, gravity: 2.0, playerHeight: 1.6 };
        const playerRadius = 0.5;
        let weapon, muzzle, weaponRecoil = 0, lastShotTime = 0;
        const raycaster = new THREE.Raycaster();
        const collidableObjects = []; 
        const shootableObjects = []; 
        const particles = []; 
        const bots = [];
        let currentWeapon = 'rifle';
        let audioCtx;

        const weapons = {
            rifle: { name: "RIFLE", damage: 34, fireRate: 150, range: 100, spread: 0.02, pellets: 1, recoil: 0.15, sound: 'shoot_rifle' },
            sniper: { name: "SNIPER", damage: 100, fireRate: 1000, range: 200, spread: 0.001, pellets: 1, recoil: 0.5, sound: 'shoot_sniper' },
            shotgun: { name: "SHOTGUN", damage: 20, fireRate: 800, range: 40, spread: 0.15, pellets: 6, recoil: 0.4, sound: 'shoot_shotgun' }
        };

        // --- AUDIO ---
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSpatialSound(type, position) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const panner = audioCtx.createStereoPanner();
            const now = audioCtx.currentTime;
            
            if (type === 'shoot_rifle') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.15);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.15);
                osc.start(now); osc.stop(now+0.2);
            } else if (type === 'shoot_sniper') {
                osc.type = 'square'; osc.frequency.setValueAtTime(1500, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.4);
                gainNode.gain.setValueAtTime(0.5, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.4);
                osc.start(now); osc.stop(now+0.4);
            } else if (type === 'shoot_shotgun') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.3);
                gainNode.gain.setValueAtTime(0.5, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.3);
                const lfo = audioCtx.createOscillator(); lfo.frequency.value = 50; lfo.connect(gainNode.gain); lfo.start(now); lfo.stop(now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'shoot_enemy') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.2);
                gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.2);
                osc.start(now); osc.stop(now+0.25);
            } else if (type === 'jump') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(300, now+0.1);
                gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.linearRampToValueAtTime(0.01, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'hit_marker' || type === 'pain') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(type==='pain'?150:2000, now);
                gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.05);
                osc.start(now); osc.stop(now+0.05);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.5);
                const lfo = audioCtx.createOscillator(); lfo.type='square'; lfo.frequency.value=50;
                const lfoGain = audioCtx.createGain(); lfoGain.gain.value=500; lfo.connect(lfoGain); lfoGain.connect(osc.frequency); lfo.start(now); lfo.stop(now+0.5);
                gainNode.gain.setValueAtTime(0.4, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now+0.5);
                osc.start(now); osc.stop(now+0.5);
            }

            if (position) {
                const dist = camera.position.distanceTo(position);
                const maxDist = 60;
                let vol = Math.max(0, 1 - (dist / maxDist));
                const distGain = audioCtx.createGain(); distGain.gain.value = vol * vol;
                const localPos = position.clone().sub(camera.position).applyQuaternion(camera.quaternion.clone().invert());
                panner.pan.value = Math.max(-1, Math.min(1, localPos.x / 20));
                osc.connect(gainNode); gainNode.connect(distGain); distGain.connect(panner); panner.connect(audioCtx.destination);
            } else {
                osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            }
        }

        function setupGUI() {
            gui = new GUI({ title: 'Configurações Dev' });
            const fp = gui.addFolder('Física');
            fp.add(physicsParams, 'speed', 10, 500); 
            fp.add(physicsParams, 'jumpForce', 10, 200); 
            fp.add(physicsParams, 'gravity', 0, 20);
            
            // Inicia escondido
            gui.hide();
        }

        function setScope(state) {
            isScoped = state;
            document.getElementById('sniper-scope').style.display = state ? 'block' : 'none';
            document.getElementById('crosshair').style.display = state ? 'none' : (controls.isLocked ? 'block' : 'none');
            camera.fov = state ? baseFov / 3 : baseFov;
            camera.updateProjectionMatrix();
            controls.sensitivity = state ? baseSensitivity * 0.3 : baseSensitivity;
            if (weapon) weapon.visible = !state;
        }

        function setupKeyboardControls() {
            const onKeyDown = (e) => {
                if (e.code==='KeyW') moveForward=true; else if (e.code==='KeyA') moveLeft=true;
                else if (e.code==='KeyS') moveBackward=true; else if (e.code==='KeyD') moveRight=true;
                else if (e.code==='ShiftLeft') isSprinting=true;
                else if (e.code==='Space' && canJump) { velocity.y += physicsParams.jumpForce; canJump=false; playSpatialSound('jump'); }
                else if (e.code === 'Digit1') switchWeapon('rifle');
                else if (e.code === 'Digit2') switchWeapon('sniper');
                else if (e.code === 'Digit3') switchWeapon('shotgun');
            };
            const onKeyUp = (e) => {
                if (e.code==='KeyW') moveForward=false; else if (e.code==='KeyA') moveLeft=false;
                else if (e.code==='KeyS') moveBackward=false; else if (e.code==='KeyD') moveRight=false;
                else if (e.code==='ShiftLeft') isSprinting=false;
            };
            document.addEventListener('mousedown', (e) => {
                // Impede tiro se clicar nos controles mobile
                if (isMobileMode && e.target.closest('.touch-zone')) return;
                
                if (gameStarted && !isGameOver && controls.isLocked) {
                    if (e.button === 0) shoot();
                    if (e.button === 2 && currentWeapon === 'sniper') setScope(true);
                }
            });
            document.addEventListener('mouseup', (e) => { if (e.button === 2) setScope(false); });
            document.addEventListener('contextmenu', event => event.preventDefault());

            // --- CORREÇÃO ESC / MENU / POINTER LOCK ---
            function onPointerLockChange() {
                // Verifica lock em todos os prefixos possíveis
                const locked = (document.pointerLockElement === document.body || 
                              document.mozPointerLockElement === document.body || 
                              document.webkitPointerLockElement === document.body);
                
                controls.isLocked = locked;
                
                if (locked) {
                    // LOCKED: Jogo ativo
                    document.getElementById('instructions').style.display = 'none';
                    document.getElementById('settings-menu').style.display = 'none';
                    document.getElementById('crosshair').style.display = 'block';
                } else {
                    // UNLOCKED: Menu de pausa
                    setScope(false); // Sai da mira
                    
                    if (gameStarted && !isGameOver) {
                        document.getElementById('instructions').style.display = 'flex';
                        document.getElementById('crosshair').style.display = 'none';
                        // Mostra botão de continuar
                        document.getElementById('btn-resume').style.display = 'inline-block';
                    }
                }
            }

            // Adiciona listeners para todos os vendors
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);

            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        }

        // --- SISTEMA MOBILE ---
        function setupMobileControls() {
            // Detecta toque
            const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            if (isTouch) enableMobileMode();

            document.getElementById('btn-mobile-toggle').addEventListener('click', () => {
                enableMobileMode();
            });

            // Joystick Movimento
            const joyL = document.getElementById('joystick-zone-l');
            const knobL = document.getElementById('joystick-knob-l');
            let joystickId = null; // Track specific touch ID
            let joyLData = { startX:0, startY:0, active: false };

            joyL.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // Se já temos um ID, ignora novos toques
                if (joystickId !== null) return;
                
                const touch = e.changedTouches[0];
                joystickId = touch.identifier;
                
                joyLData.startX = touch.clientX; 
                joyLData.startY = touch.clientY;
                joyLData.active = true;
            }, {passive: false});

            joyL.addEventListener('touchmove', (e) => {
                if(!joyLData.active) return;
                e.preventDefault();
                
                // Encontra o toque correto
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;

                let dx = touch.clientX - joyLData.startX;
                let dy = touch.clientY - joyLData.startY;
                
                // Limita o movimento do knob
                const maxDist = 50;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }
                
                knobL.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Normaliza vetor
                joystickVector.x = dx / maxDist;
                joystickVector.y = dy / maxDist;
            }, {passive: false});

            const resetJoyL = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickId) {
                        joystickId = null;
                        joyLData.active = false;
                        knobL.style.transform = `translate(-50%, -50%)`;
                        joystickVector.x = 0; joystickVector.y = 0;
                        break;
                    }
                }
            };
            joyL.addEventListener('touchend', resetJoyL);
            joyL.addEventListener('touchcancel', resetJoyL);

            // Mira (Touch Pad Direito)
            const aimZone = document.getElementById('aim-zone');
            let aimTouchId = null;
            let lastAimX = 0, lastAimY = 0;
            
            aimZone.addEventListener('touchstart', (e) => {
                if (aimTouchId !== null) return;
                const touch = e.changedTouches[0];
                aimTouchId = touch.identifier;
                lastAimX = touch.clientX;
                lastAimY = touch.clientY;
            });
            
            aimZone.addEventListener('touchmove', (e) => {
                if (!controls.isLocked && !isMobileMode) return;
                e.preventDefault();
                
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === aimTouchId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;

                const dx = touch.clientX - lastAimX;
                const dy = touch.clientY - lastAimY;
                lastAimX = touch.clientX; lastAimY = touch.clientY;
                
                // Sensibilidade mobile ajustada - REDUZIDA de 0.005 para 0.002
                const factor = 0.002 * controls.sensitivity;
                controls.rotateCamera(dx * factor, dy * factor);
            }, {passive: false});

            const resetAim = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === aimTouchId) {
                        aimTouchId = null;
                        break;
                    }
                }
            };
            aimZone.addEventListener('touchend', resetAim);
            aimZone.addEventListener('touchcancel', resetAim);

            // Botões
            document.getElementById('btn-shoot').addEventListener('touchstart', (e) => {
                e.preventDefault(); shoot();
            });
            document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
                e.preventDefault(); if(canJump) { velocity.y += physicsParams.jumpForce; canJump=false; playSpatialSound('jump'); }
            });
            document.getElementById('btn-switch').addEventListener('touchstart', (e) => {
                e.preventDefault();
                const weps = ['rifle', 'sniper', 'shotgun'];
                let idx = weps.indexOf(currentWeapon);
                idx = (idx + 1) % weps.length;
                switchWeapon(weps[idx]);
            });
             document.getElementById('btn-scope').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (currentWeapon === 'sniper') setScope(!isScoped);
            });
        }

        function enableMobileMode() {
            isMobileMode = true;
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('btn-mobile-toggle').style.display = 'none'; // Esconde botão se já ativado
            
            // Ajusta o texto de instruções
            const instr = document.querySelector('#instructions div:last-child p:last-child');
            if(instr) instr.innerText = "CONTROLES MOBILE ATIVADOS";
        }

        // --- SISTEMA DE BOTS ---
        class Bot {
            constructor(x, z, type = 'ranged') {
                this.group = new THREE.Group();
                this.health = 100;
                this.isDead = false;
                this.type = type;

                let skinColor = 0xffdbac; 
                let uniformColor = 0x2a3b4c; 
                let vestColor = 0x111111; 
                let pantsColor = 0x222222;

                if (type === 'melee') {
                    // Visual Melee (Verde Escuro)
                    skinColor = 0x8b5a2b; // Pele mais escura
                    uniformColor = 0x1e3f1e; // Verde Escuro
                    vestColor = 0x0a1f0a;
                    pantsColor = 0x112211;
                    this.health = 300; // 3x Vida
                }

                const matSkin = new THREE.MeshLambertMaterial({ color: skinColor });
                const matUniform = new THREE.MeshLambertMaterial({ color: uniformColor });
                const matVest = new THREE.MeshLambertMaterial({ color: vestColor });
                const matPants = new THREE.MeshLambertMaterial({ color: pantsColor });
                const matWeapon = new THREE.MeshLambertMaterial({ color: 0x333333 });

                this.torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.45), matUniform);
                this.torso.position.y = 1.4; this.torso.castShadow = true; this.torso.userData = { parentBot: this };
                this.group.add(this.torso);

                const vest = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.5, 0.5), matVest); vest.position.y = 0.1; this.torso.add(vest);

                this.head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.45, 0.45), matSkin);
                this.head.position.y = 0.7; this.head.castShadow = true; this.head.userData = { parentBot: this };
                this.torso.add(this.head); 

                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.15, 0.47), matVest); helmet.position.y = 0.25; this.head.add(helmet);
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.1), new THREE.MeshLambertMaterial({color: 0x111111}));
                visor.position.set(0, 0.05, 0.23); this.head.add(visor);

                this.armL = new THREE.Group(); this.armL.position.set(-0.5, 0.3, 0); this.torso.add(this.armL);
                const meshArmL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matUniform);
                meshArmL.position.y = -0.3; meshArmL.castShadow = true; meshArmL.userData = { parentBot: this };
                this.armL.add(meshArmL);

                this.armR = new THREE.Group(); this.armR.position.set(0.5, 0.3, 0); this.torso.add(this.armR);
                const meshArmR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), matUniform);
                meshArmR.position.y = -0.3; meshArmR.castShadow = true; meshArmR.userData = { parentBot: this };
                this.armR.add(meshArmR);

                const gunGroup = new THREE.Group(); gunGroup.position.set(0, -0.6, 0.2); this.armR.add(gunGroup);
                
                if (type === 'ranged') {
                    const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), matWeapon); gunGroup.add(gunBody);
                    const gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.2), new THREE.MeshLambertMaterial({color: 0x555555}));
                    gunBarrel.position.z = -0.4; gunGroup.add(gunBarrel);
                } else {
                    // Melee weapon (Bat)
                    const bat = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.8), new THREE.MeshLambertMaterial({color: 0x8b4513}));
                    bat.position.z = -0.3; gunGroup.add(bat);
                }

                this.legL = new THREE.Group(); this.legL.position.set(-0.2, -0.4, 0); this.torso.add(this.legL);
                const meshLegL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matPants);
                meshLegL.position.y = -0.4; meshLegL.castShadow = true; meshLegL.userData = { parentBot: this };
                this.legL.add(meshLegL);

                this.legR = new THREE.Group(); this.legR.position.set(0.2, -0.4, 0); this.torso.add(this.legR);
                const meshLegR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), matPants);
                meshLegR.position.y = -0.4; meshLegR.castShadow = true; meshLegR.userData = { parentBot: this };
                this.legR.add(meshLegR);

                this.group.position.set(x, 0, z); scene.add(this.group);
                
                shootableObjects.push(this.torso, this.head, meshArmL, meshArmR, meshLegL, meshLegR);

                this.direction = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                this.changeDirTimer = 0; 
                this.speed = (type === 'melee') ? 5.2 : 4.0; // 1.3x faster for melee
                this.velocity = new THREE.Vector3();
                this.isGrounded = false; 
                this.jumpTimer = Math.random()*5+2; 
                this.shootTimer = 0; 
                this.detectionRange = (type === 'melee') ? 60 : 40; 
                this.animTime = Math.random() * 100;
                
                this.isTrainingTarget = (currentMapType === 'training');
                if (this.isTrainingTarget) {
                    this.speed = Math.random() > 0.5 ? 3.0 : 0; 
                    this.direction.set(Math.random() > 0.5 ? 1 : -1, 0, 0);
                }
            }

            update(delta, playerPos) {
                if (this.isDead) return;
                
                if (this.isTrainingTarget) {
                    if (this.speed > 0) {
                        this.animTime += delta * this.speed * 2;
                        this.legL.rotation.x = Math.sin(this.animTime) * 0.5; this.legR.rotation.x = Math.cos(this.animTime) * 0.5;
                        const move = this.direction.clone().multiplyScalar(this.speed * delta);
                        const nextPos = this.group.position.clone().add(move);
                        if (nextPos.x > 20 || nextPos.x < -20) this.direction.x *= -1;
                        else this.group.position.add(move);
                    }
                    this.group.lookAt(playerPos.x, this.group.position.y, playerPos.z);
                    return;
                }

                const dist = this.group.position.distanceTo(playerPos);
                let isAggro = false;

                if (this.speed > 0.1) {
                    this.animTime += delta * this.speed * 2;
                    this.legL.rotation.x = Math.sin(this.animTime) * 0.5; this.legR.rotation.x = Math.cos(this.animTime) * 0.5;
                    this.armL.rotation.x = Math.cos(this.animTime) * 0.5;
                    if (!isAggro) this.armR.rotation.x = Math.sin(this.animTime) * 0.5;
                } else {
                    this.legL.rotation.x = 0; this.legR.rotation.x = 0; this.armL.rotation.x = 0;
                    if(!isAggro) this.armR.rotation.x = 0;
                }

                if (dist < this.detectionRange && !isGameOver) {
                    isAggro = true;
                    this.group.lookAt(playerPos.x, this.group.position.y, playerPos.z);
                    this.armR.rotation.x = -1.5; this.torso.rotation.x = 0.1;
                    
                    if (this.type === 'melee') {
                        // Lógica Melee
                        this.speed = 5.2;
                        this.direction.subVectors(playerPos, this.group.position).normalize();
                        this.direction.y = 0;

                        if (dist < 2.0) {
                            // Ataque Melee
                            this.shootTimer -= delta;
                            if (this.shootTimer <= 0) {
                                playerTakeDamage(20);
                                playSpatialSound('hit_marker'); // Som de hit
                                this.shootTimer = 1.0; // Cooldown
                            }
                        }
                    } else {
                        // Lógica Ranged
                        if (dist < 15) this.speed = 0;
                        else {
                            this.direction.subVectors(playerPos, this.group.position).normalize();
                            this.direction.y = 0; this.speed = 5.5;
                        }
                        this.shootTimer -= delta;
                        if (this.shootTimer <= 0) {
                            this.shootAtPlayer(playerPos); this.shootTimer = Math.random()*0.5 + 0.5;
                        }
                    }

                } else {
                    this.torso.rotation.x = 0; 
                    this.speed = (this.type === 'melee') ? 5.2 : 4.0;
                    this.changeDirTimer -= delta;
                    if (this.changeDirTimer <= 0) {
                        this.direction.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        this.changeDirTimer = Math.random()*3+1;
                    }
                    const lookTarget = this.group.position.clone().add(this.direction);
                    lookTarget.y = this.group.position.y;
                    this.group.lookAt(lookTarget);
                }

                this.velocity.y -= 200.0 * delta;
                this.group.position.y += this.velocity.y * delta;
                if (this.group.position.y <= 0) { this.group.position.y = 0; this.velocity.y = 0; this.isGrounded = true; } 
                else this.isGrounded = false;

                if (!isAggro && this.isGrounded) {
                    this.jumpTimer -= delta;
                    if (this.jumpTimer <= 0) { this.velocity.y = 50.0; this.jumpTimer = Math.random()*5+3; }
                }

                if (this.speed > 0) {
                    const move = this.direction.clone().multiplyScalar(this.speed * delta);
                    const nextPos = this.group.position.clone().add(move);
                    const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextPos.x, 1, nextPos.z), new THREE.Vector3(1.5, 2, 1.5));
                    
                    let col = false;
                    for (const o of collidableObjects) if (box.intersectsBox(o)) { col = true; break; }
                    if (Math.abs(nextPos.x) > MAP_SIZE/2-2 || Math.abs(nextPos.z) > MAP_SIZE/2-2) col = true;

                    if (!col) { 
                        this.group.position.x = nextPos.x; this.group.position.z = nextPos.z; 
                    } else if (isAggro && this.type === 'melee') {
                        // Tenta deslizar/contornar obstáculos para melee
                        // Tenta mover apenas em X
                        const moveX = move.clone(); moveX.z = 0;
                        const nextPosX = this.group.position.clone().add(moveX);
                        const boxX = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextPosX.x, 1, nextPosX.z), new THREE.Vector3(1.5, 2, 1.5));
                        let colX = false; for (const o of collidableObjects) if (boxX.intersectsBox(o)) { colX = true; break; }
                        
                        if (!colX) {
                            this.group.position.x = nextPosX.x;
                        } else {
                            // Tenta mover apenas em Z
                            const moveZ = move.clone(); moveZ.x = 0;
                            const nextPosZ = this.group.position.clone().add(moveZ);
                            const boxZ = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextPosZ.x, 1, nextPosZ.z), new THREE.Vector3(1.5, 2, 1.5));
                            let colZ = false; for (const o of collidableObjects) if (boxZ.intersectsBox(o)) { colZ = true; break; }
                            if (!colZ) this.group.position.z = nextPosZ.z;
                        }
                    } else if (!isAggro) {
                        this.direction.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        this.changeDirTimer = 1;
                    }
                }
            }

            shootAtPlayer(playerPos) {
                const start = this.group.position.clone(); start.y += 1.8;
                playSpatialSound('shoot_enemy', start);
                const dir = new THREE.Vector3().subVectors(playerPos, start).normalize();
                const dist = start.distanceTo(playerPos);
                const ray = new THREE.Raycaster(start, dir, 0, dist);
                const hits = ray.intersectObjects(shootableObjects, true);
                let blocked = false, hitPoint = null;
                for (const h of hits) {
                    if (h.object.userData && h.object.userData.parentBot === this) continue;
                    blocked = true; hitPoint = h.point; createParticles(h.point, 0xffff00, 3); break;
                }
                let target = blocked ? hitPoint : playerPos.clone().add(new THREE.Vector3((Math.random()-0.5)*2, -0.5 + (Math.random()-0.5), (Math.random()-0.5)*2));
                createBulletTracer(start, target, 0xff0000);
                if (!blocked && this.group.position.distanceTo(playerPos) < 40) {
                    if (Math.random() < Math.max(0.2, 1 - (dist/50))) playerTakeDamage(10);
                }
            }

            takeDamage(amount) {
                if (this.isDead) return;
                this.health -= amount;
                playSpatialSound('hit_marker');
                this.group.traverse((c) => { if(c.isMesh) c.material.emissive.setHex(0xffffff); });
                setTimeout(() => { if (!this.isDead) this.group.traverse((c) => { if(c.isMesh) c.material.emissive.setHex(0x000000); }); }, 100);
                if (this.health <= 0) this.die();
            }

            die() {
                this.isDead = true;
                addScore(100); addToKillFeed("Inimigo Eliminado +100");
                playSpatialSound('explosion', this.group.position);
                this.group.rotation.x = -Math.PI / 2; this.group.position.y = 0.5;
                createParticles(this.group.position.clone().add(new THREE.Vector3(0, 1.5, 0)), 0xff0000, 20);
                setTimeout(() => {
                    scene.remove(this.group);
                    bots.splice(bots.indexOf(this), 1);
                    this.group.traverse((c) => {
                        if(c.isMesh) {
                            const idx = shootableObjects.indexOf(c);
                            if(idx > -1) shootableObjects.splice(idx, 1);
                        }
                    });
                    if (currentMapType === 'training') spawnTrainingBot(); 
                    else {
                        // Respawn aleatório de tipo
                        const r = Math.random();
                        // Tenta manter proporção 8 ranged 3 melee (aprox)
                        if (r > 0.7) spawnBot('melee'); else spawnBot('ranged');
                    }
                }, 500);
            }
        }

        // --- AUXILIARES ---
        function createWeapon() {
            weapon = new THREE.Group();
            const dark = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const grey = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const wood = new THREE.MeshLambertMaterial({ color: 0x5c4033 });
            const green = new THREE.MeshLambertMaterial({ color: 0x2e3b2a });

            const type = currentWeapon;
            if (type === 'rifle') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), dark); body.position.z = 0.1; weapon.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8), grey); barrel.rotateX(Math.PI/2); barrel.position.set(0, 0.02, -0.3); weapon.add(barrel);
                muzzle = new THREE.Object3D(); muzzle.position.set(0, 0.02, -0.52); weapon.add(muzzle);
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.3), dark); stock.position.set(0, -0.02, 0.5); weapon.add(stock);
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.1), grey); mag.position.set(0, -0.15, 0.1); mag.rotation.x = 0.2; weapon.add(mag);
                const scope = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.15), dark); scope.position.set(0, 0.08, 0.1); weapon.add(scope);
            } 
            else if (type === 'sniper') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.14, 0.6), green); body.position.set(0, 0, 0.1); weapon.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 1.1, 8), dark); barrel.rotation.x = Math.PI/2; barrel.position.set(0, 0.02, -0.7); weapon.add(barrel);
                const brake = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.12), dark); brake.position.set(0, 0.02, -1.3); weapon.add(brake);
                muzzle = new THREE.Object3D(); muzzle.position.set(0, 0.02, -1.4); weapon.add(muzzle);
                const scopeMount = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.2), dark); scopeMount.position.set(0, 0.09, 0.1); weapon.add(scopeMount);
                const scopeTube = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.05, 0.45, 16), dark); scopeTube.rotation.x = Math.PI/2; scopeTube.position.set(0, 0.13, 0.05); weapon.add(scopeTube);
                const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.01, 16), new THREE.MeshBasicMaterial({color: 0x000000})); lens.rotation.x = Math.PI/2; lens.position.set(0, 0.13, -0.18); weapon.add(lens);
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.12, 0.4), green); stock.position.set(0, -0.02, 0.55); weapon.add(stock);
                const cheekRest = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.02, 0.2), dark); cheekRest.position.set(0, 0.05, 0.55); weapon.add(cheekRest);
                const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), grey); bolt.position.set(0.08, 0.02, 0.25); weapon.add(bolt);
                const boltKnob = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.03, 0.03), dark); boltKnob.position.set(0.11, 0.02, 0.25); weapon.add(boltKnob);
                const bipod = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.25), dark); bipod.position.set(0, -0.09, -0.4); weapon.add(bipod);
            }
            else if (type === 'shotgun') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.5), wood); body.position.z = 0.1; weapon.add(body);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8), grey); barrel.rotateX(Math.PI/2); barrel.position.set(0, 0.05, -0.35); weapon.add(barrel);
                const pump = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.2), wood); pump.position.set(0, -0.05, -0.3); weapon.add(pump);
                muzzle = new THREE.Object3D(); muzzle.position.set(0, 0.05, -0.62); weapon.add(muzzle);
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.3), wood); stock.position.set(0, -0.05, 0.4); weapon.add(stock);
            }

            weapon.position.set(0.3, -0.3, -0.6);
            // IMPORTANTE: Adiciona arma à câmera
            camera.add(weapon);
            
            document.getElementById('weapon-name').innerText = weapons[type].name;
        }

        function switchWeapon(type) {
            if (isScoped) setScope(false);
            currentWeapon = type;
            if (weapon) camera.remove(weapon);
            createWeapon();
        }

        function createBulletTracer(start, end, color) {
            const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: color, linewidth: 2 }));
            scene.add(line); setTimeout(() => { scene.remove(line); geo.dispose(); }, 100);
        }

        function createParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const p = new THREE.Mesh(geo, mat); p.position.copy(pos);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10), life: 1.0 };
                scene.add(p); particles.push(p);
            }
        }

        function updateParticles(delta) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel.clone().multiplyScalar(delta));
                p.userData.vel.y -= 15.0 * delta; p.userData.life -= delta*2;
                p.scale.setScalar(p.userData.life);
                if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }
        }

        function addScore(pts) { score+=pts; kills++; document.getElementById('score-val').innerText=score; document.getElementById('kills-val').innerText="KILLS: "+kills; }
        function addToKillFeed(txt) {
            const el = document.createElement('div'); el.className='feed-item'; el.innerText=txt;
            document.getElementById('kill-feed').prepend(el);
            setTimeout(() => el.remove(), 4000);
        }

        function playerTakeDamage(amt) {
            if (isGameOver) return;
            playerHealth -= amt; lastDamageTime = performance.now();
            updateHUD(); playSpatialSound('pain');
            const ov = document.getElementById('damage-overlay');
            ov.style.boxShadow = "inset 0 0 0 50px rgba(255, 0, 0, 0.4)";
            setTimeout(() => ov.style.boxShadow = "none", 200);
            if (playerHealth <= 0) {
                isGameOver = true; controls.unlock();
                document.getElementById('final-score').innerText = score;
                document.getElementById('final-kills').innerText = kills;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('hud-container').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('sniper-scope').style.display = 'none';
                document.getElementById('mobile-controls').style.display = 'none';
                document.getElementById('btn-resume').style.display = 'none';
            }
        }

        function updateHUD() {
            const fill = document.getElementById('health-bar-fill');
            document.getElementById('health-text').innerText = Math.ceil(playerHealth);
            fill.style.width = playerHealth + "%";
            fill.style.backgroundColor = playerHealth < 30 ? "#ff0000" : (playerHealth < 60 ? "#ffff00" : "#00ff00");
        }

        function spawnBot(forcedType) {
            const range = MAP_SIZE / 2 - 5;
            let attempts = 0, valid = false, x = 0, z = 0;
            while (!valid && attempts < 50) {
                x = (Math.random()-0.5)*2*range; z = (Math.random()-0.5)*2*range;
                if (Math.abs(x) < 20 && Math.abs(z) < 20) { attempts++; continue; }
                const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 1, z), new THREE.Vector3(1.5, 2, 1.5));
                let col = false; for (const o of collidableObjects) if (box.intersectsBox(o)) { col = true; break; }
                if (!col) valid = true; attempts++;
            }
            // Usa tipo forçado ou 'ranged' padrão
            bots.push(new Bot(x, z, forcedType || 'ranged'));
        }

        function spawnTrainingBot() {
            const x = (Math.random() - 0.5) * 40;
            const z = -10 - (Math.random() * 40);
            bots.push(new Bot(x, z, 'ranged'));
        }

        function generateTrainingMap() {
            const wallColor = 0xcccccc; const floorColor = 0x222222; const orange = 0xffa500;
            
            // CORREÇÃO: Adicionado Piso para a área dos inimigos
            const floor = new THREE.Mesh(new THREE.BoxGeometry(60, 1, 120), new THREE.MeshLambertMaterial({ color: 0x222222 }));
            floor.position.set(0, -0.5, 0); // Just below y=0
            floor.receiveShadow = true;
            mapGroup.add(floor);
            collidableObjects.push(new THREE.Box3().setFromObject(floor));
            shootableObjects.push(floor);

            const createBlock = (x, y, z, w, h, d, color) => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color: color }));
                mesh.position.set(x, y + h/2, z); mesh.castShadow = true; mesh.receiveShadow = true;
                mapGroup.add(mesh); collidableObjects.push(new THREE.Box3().setFromObject(mesh)); shootableObjects.push(mesh);
            };
            createBlock(0, 0, 25, 20, 1, 10, 0x444444); 
            createBlock(-10.5, 0, 25, 1, 3, 10, wallColor); createBlock(10.5, 0, 25, 1, 3, 10, wallColor); createBlock(0, 0, 30.5, 22, 4, 1, wallColor);
            [10, 20, 30, 40].forEach(dist => {
                const line = new THREE.Mesh(new THREE.BoxGeometry(40, 0.1, 0.5), new THREE.MeshBasicMaterial({ color: orange }));
                line.position.set(0, 0.05, -dist); mapGroup.add(line);
            });
            createBlock(-25, 0, -20, 1, 6, 80, wallColor); createBlock(25, 0, -20, 1, 6, 80, wallColor); createBlock(0, 0, -60, 51, 8, 1, wallColor);
            createBlock(-15, 0, -10, 2, 4, 2, 0x333333); createBlock(15, 0, -30, 2, 4, 2, 0x333333);
        }

        // --- MAPAS ---
        function clearMap() {
            while(mapGroup.children.length > 0){ 
                const child = mapGroup.children[0]; mapGroup.remove(child); 
                if(child.geometry) child.geometry.dispose(); if(child.material) child.material.dispose();
            }
            collidableObjects.length = 0;
            const floor = shootableObjects.find(o => o.geometry && o.geometry.type === 'PlaneGeometry');
            shootableObjects.length = 0; if(floor) shootableObjects.push(floor);
        }

        function createObj(x, z, type) {
            let mesh;
            if (type === 'building') {
                const h = Math.random()*15+5;
                mesh = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE-1, h, TILE_SIZE-1), new THREE.MeshLambertMaterial({ color: Math.random()*0xffffff }));
                mesh.position.set(x, h/2, z);
            } else if (type === 'car') {
                mesh = new THREE.Group();
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(2,0.8,4), new THREE.MeshLambertMaterial({color:0xd32f2f}));
                chassis.position.y = 0.6; mesh.add(chassis); shootableObjects.push(chassis);
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.6,2), new THREE.MeshLambertMaterial({color:0x111111}));
                cabin.position.set(0,1.3,-0.5); mesh.add(cabin); shootableObjects.push(cabin);
                mesh.position.set(x,0,z); mesh.rotation.y = Math.floor(Math.random()*4)*Math.PI/2;
            } else {
                const isBox = Math.random()>0.5;
                if(isBox) {
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshLambertMaterial({color:0x8d6e63}));
                    mesh.position.set(x,0.75,z);
                } else {
                    mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,1.8,10), new THREE.MeshLambertMaterial({color:0x2e7d32}));
                    mesh.position.set(x,0.9,z);
                }
            }
            if(type !== 'car') shootableObjects.push(mesh);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mapGroup.add(mesh); collidableObjects.push(new THREE.Box3().setFromObject(mesh));
        }

        function generateCity() {
            // CORREÇÃO: Adiciona chão no mapa procedural
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshLambertMaterial({ color: 0x222222 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);
            shootableObjects.push(floor);

            for (let x = -MAP_SIZE/2; x < MAP_SIZE/2; x += TILE_SIZE) {
                for (let z = -MAP_SIZE/2; z < MAP_SIZE/2; z += TILE_SIZE) {
                    const posX = x + TILE_SIZE/2, posZ = z + TILE_SIZE/2;
                    if (Math.abs(posX) < 15 && Math.abs(posZ) < 15) continue;
                    const r = Math.random();
                    if (r > 0.85) createObj(posX, posZ, 'building');
                    else if (r > 0.82) createObj(posX, posZ, 'car');
                    else if (r > 0.75) createObj(posX, posZ, 'obstacle');
                }
            }
        }

        function generateStaticMap() {
            const wallColor = 0xe0cda8; const crateColor = 0x8d6e63;
            const createWall = (x, z, w, d, h, color) => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color: color || wallColor }));
                mesh.position.set(x, h/2, z); mesh.castShadow = true; mesh.receiveShadow = true;
                mapGroup.add(mesh); collidableObjects.push(new THREE.Box3().setFromObject(mesh)); shootableObjects.push(mesh);
            };
            
            // CORREÇÃO: Chão para mapa estático
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshLambertMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);
            shootableObjects.push(floor);

            const mapLimit = 100; const wallH = 15;
            createWall(0, -mapLimit, 200, 4, wallH, 0x555555); createWall(0, mapLimit, 200, 4, wallH, 0x555555);
            createWall(-mapLimit, 0, 4, 200, wallH, 0x555555); createWall(mapLimit, 0, 4, 200, wallH, 0x555555);
            createWall(0, 0, 20, 20, 8, 0xdba765);
            createWall(-18, 0, 4, 12, 4); createWall(18, 0, 4, 12, 4); createWall(0, -18, 12, 4, 4); createWall(0, 18, 12, 4, 4);
            createWall(-50, 0, 2, 140, 6, 0x888888); createObj(-75, 0, 'car'); createObj(-75, 40, 'obstacle'); createObj(-75, -40, 'obstacle');
            createWall(50, 0, 2, 140, 6, 0x888888);
            for(let z = -60; z <= 60; z += 30) { createWall(70, z, 10, 10, 3, crateColor); if (z !== 0) createWall(60, z - 15, 2, 10, 4, wallColor); }
            createWall(0, -85, 40, 2, 6, 0x607d8b); createWall(-30, -70, 2, 20, 6); createWall(30, -70, 2, 20, 6);
            createWall(0, 85, 40, 2, 6, 0x607d8b); createWall(-30, 70, 2, 20, 6); createWall(30, 70, 2, 20, 6);
            createObj(-30, -30, 'obstacle'); createObj(30, 30, 'obstacle'); createObj(30, -30, 'obstacle'); createObj(-30, 30, 'obstacle');
        }

        // --- GAME LOOP ---
        function startGame(mode) {
            initAudio();
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('crosshair').style.display = 'block';
            
            // Lógica melhorada para evitar "piscar" e problemas de foco
            if (isMobileMode) {
                 // Mobile não tem pointer lock real, então escondemos manualmente
                 document.getElementById('instructions').style.display = 'none';
                 controls.lock();
            } else {
                 // PC depende do evento do navegador para esconder o menu
                 // Solicitamos o lock, se funcionar, o evento pointerlockchange esconde o menu
                 controls.lock();
            }
            
            gameStarted = true;
            currentMapType = mode;
            playerHealth = 100; score = 0; kills = 0;
            updateHUD();
            document.getElementById('score-val').innerText = 0;
            document.getElementById('kills-val').innerText = "KILLS: 0";
            clearMap();

            if (mode === 'procedural') { 
                generateCity(); respawnPlayerSafe(0, 0); 
            } else if (mode === 'static') { 
                generateStaticMap(); respawnPlayerSafe(0, 80); controls.getObject().rotation.y = Math.PI; 
            } else if (mode === 'training') {
                generateTrainingMap(); 
                controls.getObject().position.set(0, 2.6, 25); 
                controls.getObject().rotation.y = Math.PI;
                velocity.set(0,0,0);
            }

            for(let b of bots) scene.remove(b.group);
            bots.length = 0;
            
            if (mode === 'training') {
                for(let i=0; i<5; i++) spawnTrainingBot();
            } else {
                for(let i=0; i<8; i++) spawnBot('ranged');
                for(let i=0; i<3; i++) spawnBot('melee');
            }
        }

        function respawnPlayerSafe(targetX, targetZ) {
            const playerObj = controls.getObject();
            let x = targetX, z = targetZ, y = physicsParams.playerHeight, safe = false, attempts = 0;
            while (!safe && attempts < 100) {
                const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, y, z), new THREE.Vector3(1, 2, 1));
                let collision = false;
                for (const obj of collidableObjects) if (box.intersectsBox(obj)) { collision = true; break; }
                if (!collision) safe = true;
                else {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 2 + (attempts * 0.5);
                    x = targetX + Math.cos(angle) * dist; z = targetZ + Math.sin(angle) * dist;
                    if (attempts % 10 === 0) y += 1;
                }
                attempts++;
            }
            playerObj.position.set(x, y, z); velocity.set(0, 0, 0);
        }

        function shoot() {
            const stats = weapons[currentWeapon];
            const now = performance.now();
            if (now - lastShotTime < stats.fireRate) return;
            lastShotTime = now;
            weaponRecoil += stats.recoil; 
            if(weapon) weapon.updateMatrixWorld();
            playSpatialSound(stats.sound); 
            for (let i = 0; i < stats.pellets; i++) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                if (stats.spread > 0) {
                    raycaster.ray.direction.x += (Math.random() - 0.5) * stats.spread;
                    raycaster.ray.direction.y += (Math.random() - 0.5) * stats.spread;
                    raycaster.ray.direction.z += (Math.random() - 0.5) * stats.spread;
                    raycaster.ray.direction.normalize();
                }
                const intersects = raycaster.intersectObjects(shootableObjects, false);
                const start = new THREE.Vector3();
                if(muzzle) muzzle.getWorldPosition(start); else weapon.children[1].getWorldPosition(start);
                let end = new THREE.Vector3(); raycaster.ray.at(100, end);
                if (intersects.length > 0) {
                    end.copy(intersects[0].point);
                    const obj = intersects[0].object;
                    let dmg = stats.damage;
                    
                    // Falloff de Dano para Shotgun
                    if (currentWeapon === 'shotgun') {
                        const distToTarget = start.distanceTo(end);
                        if (distToTarget < 10) dmg = 50; // Close range
                        else if (distToTarget < 20) dmg = 20; // Mid range
                        else dmg = 5; // Long range
                    }

                    if (obj.userData && obj.userData.parentBot) {
                        obj.userData.parentBot.takeDamage(dmg); createParticles(end, 0xff0000, 8);
                    } else { createParticles(end, 0xffff00, 5); }
                    if(obj.material && obj.material.emissive && !obj.userData.parentBot) {
                        // Correção para highlight Shotgun
                        if (obj.material.emissive.getHex() !== 0xff0000) {
                            const old = obj.material.emissive.getHex(); obj.material.emissive.setHex(0xff0000);
                            setTimeout(() => { if(obj.material) obj.material.emissive.setHex(old); }, 100);
                        }
                    }
                }
                createBulletTracer(start, end, 0xffff00);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); const delta = (time - prevTime) / 1000;
            updateParticles(delta);
            if (playerHealth < 100 && !isGameOver && (time - lastDamageTime > 5000)) {
                playerHealth = Math.min(100, playerHealth + (10 * delta)); updateHUD();
            }
            bots.forEach(b => b.update(delta, camera.position));

            if ((controls.isLocked || isMobileMode) && !isGameOver) {
                // FRICTION
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // GRAVITY
                velocity.y -= physicsParams.gravity * 100.0 * delta;

                // Ground Check
                raycaster.set(controls.getObject().position, new THREE.Vector3(0, -1, 0));
                const environment = shootableObjects.filter(obj => !obj.userData.parentBot);
                const intersections = raycaster.intersectObjects(environment, false);
                let groundY = 0;
                if (intersections.length > 0) groundY = intersections[0].point.y;

                // INPUT
                direction.set(0, 0, 0);
                if (isMobileMode) {
                    direction.z = -joystickVector.y; 
                    direction.x = joystickVector.x;
                } else {
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();
                }

                const spd = isSprinting ? physicsParams.speed * 2 : physicsParams.speed;
                
                if (direction.lengthSq() > 0) {
                      velocity.z -= direction.z * spd * delta;
                      velocity.x -= direction.x * spd * delta;
                }
                
                // --- PHYSICS: WALL SLIDING (Separating Axis) ---
                
                // 1. Calcular o vetor de deslocamento desejado no MUNDO
                // Extrair vetores Right e Forward da câmera
                const vecRight = new THREE.Vector3();
                vecRight.setFromMatrixColumn(camera.matrix, 0); // Local X
                
                const vecForward = new THREE.Vector3();
                vecForward.crossVectors(camera.up, vecRight); // Local -Z (Forward)

                // Combinar input local para obter deslocamento global
                const displacement = new THREE.Vector3();
                displacement.addScaledVector(vecRight, -velocity.x * delta);
                displacement.addScaledVector(vecForward, -velocity.z * delta);

                const startPos = controls.getObject().position.clone();
                const playerBox = new THREE.Box3();
                const playerSize = new THREE.Vector3(1, 2, 1); // Hitbox do jogador

                // 2. Tentar mover no Eixo X (Mundo)
                controls.getObject().position.x += displacement.x;
                playerBox.setFromCenterAndSize(controls.getObject().position, playerSize);
                
                if (collidableObjects.some(o => playerBox.intersectsBox(o))) {
                    // Colidiu em X, reverte X
                    controls.getObject().position.x = startPos.x;
                }

                // 3. Tentar mover no Eixo Z (Mundo)
                controls.getObject().position.z += displacement.z;
                playerBox.setFromCenterAndSize(controls.getObject().position, playerSize);

                if (collidableObjects.some(o => playerBox.intersectsBox(o))) {
                    // Colidiu em Z, reverte Z
                    controls.getObject().position.z = startPos.z;
                }

                // 4. Movimento Vertical (Y)
                controls.getObject().position.y += (velocity.y * delta);
                
                // Colisão com Chão
                if (controls.getObject().position.y < groundY + physicsParams.playerHeight) {
                    velocity.y = 0; 
                    controls.getObject().position.y = groundY + physicsParams.playerHeight; 
                    canJump = true;
                }

                // Weapon Bobbing
                if (weapon) {
                    const isMoving = velocity.x * velocity.x + velocity.z * velocity.z > 1;
                    if(isMoving) { weapon.position.x = 0.3 + Math.cos(time*0.01)*0.02; weapon.position.y = -0.3 + Math.sin(time*0.02)*0.02; }
                    else { weapon.position.x += (0.3-weapon.position.x)*0.1; weapon.position.y += (-0.3-weapon.position.y)*0.1; }
                    if (weaponRecoil > 0) {
                        weapon.position.z = -0.6 + weaponRecoil; weapon.rotation.x = weaponRecoil * 2;
                        weaponRecoil = Math.max(0, weaponRecoil - delta * 1.5);
                    } else { weapon.position.z = -0.6; weapon.rotation.x = 0; }
                }
            }
            prevTime = time; renderer.render(scene, camera);
        }

        // --- INICIALIZAÇÃO CORRIGIDA ---
        function init() {
            // 1. Scene & Fog
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 150);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            document.body.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Map Group
            mapGroup = new THREE.Group();
            scene.add(mapGroup);

            // 6. Controls
            controls = new FPSControls(camera, document.body);

            // 7. Setup Inputs & UI
            setupKeyboardControls();
            setupMobileControls();
            setupGUI();

            // 8. Event Listeners for UI Buttons
            document.getElementById('btn-procedural').addEventListener('click', (e) => { e.stopPropagation(); startGame('procedural'); });
            document.getElementById('btn-static').addEventListener('click', (e) => { e.stopPropagation(); startGame('static'); });
            document.getElementById('btn-training').addEventListener('click', (e) => { e.stopPropagation(); startGame('training'); });
            
            // Botão Resume
            document.getElementById('btn-resume').addEventListener('click', (e) => {
                e.stopPropagation();
                if(gameStarted && !isGameOver) controls.lock();
            });

            // CORREÇÃO: Permitir clicar em qualquer lugar da tela de menu para voltar
            // Isso resolve o "limbo" se o ponteiro destravar sem querer
            document.addEventListener('click', (e) => {
                if(gameStarted && !isGameOver && !controls.isLocked) {
                    controls.lock();
                }
            });

            // Settings Menu Logic
            const settingsMenu = document.getElementById('settings-menu');
            const instructions = document.getElementById('instructions');
            
            document.getElementById('btn-settings').addEventListener('click', (e) => {
                e.stopPropagation();
                instructions.style.display = 'none';
                settingsMenu.style.display = 'flex';
            });

            document.getElementById('btn-save-settings').addEventListener('click', (e) => {
                e.stopPropagation();
                const val = parseFloat(document.getElementById('sens-input').value);
                if(val > 0) baseSensitivity = val;
                controls.sensitivity = baseSensitivity;
                settingsMenu.style.display = 'none';
                instructions.style.display = 'flex';
            });

            document.getElementById('btn-dev-mode').addEventListener('click', (e) => {
                e.stopPropagation();
                isDevMode = !isDevMode;
                e.target.innerText = "MODO DEV: " + (isDevMode ? "ON" : "OFF");
                if(isDevMode) gui.show(); else gui.hide();
            });

            // 9. Window Resize
            window.addEventListener('resize', onWindowResize, false);
            
            // 10. Initial Weapon (CORREÇÃO: Scene Add Camera)
            scene.add(camera);
            createWeapon();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init(); animate();
    </script>
</body>
</html>
